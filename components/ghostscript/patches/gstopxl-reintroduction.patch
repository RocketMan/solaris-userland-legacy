Ghostscript has first renamed pstopxl and pstoraster programs and then completely
removed them / moved them to cups-filters. Solaris does not have cups-filters
just yet, but some customers need pstopxl to print. This patch reintroduces these
removed utilities back to Ghostscript.

Files are taken from commit removing them from the Ghostscript and slightly
changed to work with the current version.
http://git.ghostscript.com/?p=ghostpdl.git;h=9304a21699a6c17579fae32f44f5c92a37c13e2d

pstopxl and pstopxl.in were slightly updated to work with Solaris.

This patch will become obsolete with the introduction of new cups2 and cups-filters.

--- /dev/null
+++ ghostscript-9.26/cups/colord.c
@@ -0,0 +1,464 @@
+/*
+Copyright (c) 2011, Tim Waugh
+Copyright (c) 2011-2013, Richard Hughes
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+MIT Open Source License  -  http://www.opensource.org/
+
+*/
+
+
+/* Common routines for accessing the colord CMS framework */
+
+#include <cups/raster.h>
+#include <stdio.h>
+#include <sys/types.h>
+
+#ifdef HAVE_DBUS
+  #include <dbus/dbus.h>
+#endif
+
+#include "colord.h"
+
+#define QUAL_COLORSPACE   0
+#define QUAL_MEDIA        1
+#define QUAL_RESOLUTION   2
+#define QUAL_SIZE         3
+
+char **
+colord_get_qualifier_for_ppd (ppd_file_t *ppd)
+{
+  char q_keyword[PPD_MAX_NAME];
+  char **tuple = NULL;
+  const char *q1_choice;
+  const char *q2_choice;
+  const char *q3_choice;
+  ppd_attr_t *attr;
+  ppd_attr_t *q1_attr;
+  ppd_attr_t *q2_attr;
+  ppd_attr_t *q3_attr;
+
+  /* get colorspace */
+  if ((attr = ppdFindAttr (ppd, "cupsICCQualifier1", NULL)) != NULL &&
+      attr->value && attr->value[0])
+  {
+    snprintf (q_keyword, sizeof (q_keyword), "Default%s", attr->value);
+    q1_attr = ppdFindAttr (ppd, q_keyword, NULL);
+  }
+  else if ((q1_attr = ppdFindAttr (ppd, "DefaultColorModel", NULL)) == NULL)
+    q1_attr = ppdFindAttr (ppd, "DefaultColorSpace", NULL);
+
+  if (q1_attr && q1_attr->value && q1_attr->value[0])
+    q1_choice = q1_attr->value;
+  else
+    q1_choice = "";
+
+  /* get media */
+  if ((attr = ppdFindAttr(ppd, "cupsICCQualifier2", NULL)) != NULL &&
+      attr->value && attr->value[0])
+  {
+    snprintf(q_keyword, sizeof(q_keyword), "Default%s", attr->value);
+    q2_attr = ppdFindAttr(ppd, q_keyword, NULL);
+  }
+  else
+    q2_attr = ppdFindAttr(ppd, "DefaultMediaType", NULL);
+
+  if (q2_attr && q2_attr->value && q2_attr->value[0])
+    q2_choice = q2_attr->value;
+  else
+    q2_choice = "";
+
+  /* get resolution */
+  if ((attr = ppdFindAttr(ppd, "cupsICCQualifier3", NULL)) != NULL &&
+      attr->value && attr->value[0])
+  {
+    snprintf(q_keyword, sizeof(q_keyword), "Default%s", attr->value);
+    q3_attr = ppdFindAttr(ppd, q_keyword, NULL);
+  }
+  else
+    q3_attr = ppdFindAttr(ppd, "DefaultResolution", NULL);
+
+  if (q3_attr && q3_attr->value && q3_attr->value[0])
+    q3_choice = q3_attr->value;
+  else
+    q3_choice = "";
+
+  /* return a NULL terminated array so we don't have to break it up later */
+  tuple = calloc(QUAL_SIZE + 1, sizeof(char*));
+  tuple[QUAL_COLORSPACE] = strdup(q1_choice);
+  tuple[QUAL_MEDIA]      = strdup(q2_choice);
+  tuple[QUAL_RESOLUTION] = strdup(q3_choice);
+  return tuple;
+}
+
+#ifdef HAVE_DBUS
+
+static char *
+get_filename_for_profile_path (DBusConnection *con,
+                               const char *object_path)
+{
+  char *filename = NULL;
+  const char *interface = "org.freedesktop.ColorManager.Profile";
+  const char *property = "Filename";
+  const char *tmp;
+  DBusError error;
+  DBusMessageIter args;
+  DBusMessage *message = NULL;
+  DBusMessage *reply = NULL;
+  DBusMessageIter sub;
+
+  message = dbus_message_new_method_call("org.freedesktop.ColorManager",
+                 object_path,
+                 "org.freedesktop.DBus.Properties",
+                 "Get");
+
+  dbus_message_iter_init_append(message, &args);
+  dbus_message_iter_append_basic(&args, DBUS_TYPE_STRING, &interface);
+  dbus_message_iter_append_basic(&args, DBUS_TYPE_STRING, &property);
+
+  /* send syncronous */
+  dbus_error_init(&error);
+  fprintf(stderr, "DEBUG: Calling %s.Get(%s)\n", interface, property);
+  reply = dbus_connection_send_with_reply_and_block(con,
+                message,
+                -1,
+                &error);
+  if (reply == NULL) {
+    fprintf(stderr, "DEBUG: Failed to send: %s:%s\n",
+           error.name, error.message);
+    dbus_error_free(&error);
+    goto out;
+  }
+
+  /* get reply data */
+  dbus_message_iter_init(reply, &args);
+  if (dbus_message_iter_get_arg_type(&args) != DBUS_TYPE_VARIANT) {
+    fprintf(stderr, "DEBUG: Incorrect reply type\n");
+    goto out;
+  }
+
+  dbus_message_iter_recurse(&args, &sub);
+  dbus_message_iter_get_basic(&sub, &tmp);
+  filename = strdup(tmp);
+out:
+  if (message != NULL)
+    dbus_message_unref(message);
+  if (reply != NULL)
+    dbus_message_unref(reply);
+  return filename;
+}
+
+static char *
+get_profile_for_device_path (DBusConnection *con,
+                             const char *object_path,
+                             const char **split)
+{
+  char **key = NULL;
+  char *profile = NULL;
+  char str[256];
+  const char *tmp;
+  DBusError error;
+  DBusMessageIter args;
+  DBusMessageIter entry;
+  DBusMessage *message = NULL;
+  DBusMessage *reply = NULL;
+  int i = 0;
+  const int max_keys = 7;
+
+  message = dbus_message_new_method_call("org.freedesktop.ColorManager",
+                                         object_path,
+                                         "org.freedesktop.ColorManager.Device",
+                                         "GetProfileForQualifiers");
+  dbus_message_iter_init_append(message, &args);
+
+  /* create the fallbacks */
+  key = calloc(max_keys + 1, sizeof(char*));
+
+  /* exact match */
+  i = 0;
+  snprintf(str, sizeof(str), "%s.%s.%s",
+           split[QUAL_COLORSPACE],
+           split[QUAL_MEDIA],
+           split[QUAL_RESOLUTION]);
+  key[i++] = strdup(str);
+  snprintf(str, sizeof(str), "%s.%s.*",
+           split[QUAL_COLORSPACE],
+           split[QUAL_MEDIA]);
+  key[i++] = strdup(str);
+  snprintf(str, sizeof(str), "%s.*.%s",
+           split[QUAL_COLORSPACE],
+           split[QUAL_RESOLUTION]);
+  key[i++] = strdup(str);
+  snprintf(str, sizeof(str), "%s.*.*",
+           split[QUAL_COLORSPACE]);
+  key[i++] = strdup(str);
+  key[i++] = strdup("*");
+  dbus_message_iter_open_container(&args,
+                                   DBUS_TYPE_ARRAY,
+                                   "s",
+                                   &entry);
+  for (i=0; key[i] != NULL; i++) {
+    dbus_message_iter_append_basic(&entry,
+                                   DBUS_TYPE_STRING,
+                                   &key[i]);
+  }
+  dbus_message_iter_close_container(&args, &entry);
+
+  /* send syncronous */
+  dbus_error_init(&error);
+  fprintf(stderr, "DEBUG: Calling GetProfileForQualifiers(%s...)\n", key[0]);
+  reply = dbus_connection_send_with_reply_and_block(con,
+                                                    message,
+                                                    -1,
+                                                    &error);
+  if (reply == NULL) {
+    fprintf(stderr, "DEBUG: Failed to send: %s:%s\n",
+           error.name, error.message);
+    dbus_error_free(&error);
+    goto out;
+  }
+
+  /* get reply data */
+  dbus_message_iter_init(reply, &args);
+  if (dbus_message_iter_get_arg_type(&args) != DBUS_TYPE_OBJECT_PATH) {
+    fprintf(stderr, "DEBUG: Incorrect reply type\n");
+    goto out;
+  }
+  dbus_message_iter_get_basic(&args, &tmp);
+  fprintf(stderr, "DEBUG: Found profile %s\n", tmp);
+
+  /* get filename */
+  profile = get_filename_for_profile_path(con, tmp);
+
+out:
+  if (message != NULL)
+    dbus_message_unref(message);
+  if (reply != NULL)
+    dbus_message_unref(reply);
+  if (key != NULL) {
+    for (i=0; i < max_keys; i++)
+      free(key[i]);
+    free(key);
+  }
+  return profile;
+}
+
+static char *
+get_device_path_for_device_id (DBusConnection *con,
+                               const char *device_id)
+{
+  char *device_path = NULL;
+  const char *device_path_tmp;
+  DBusError error;
+  DBusMessageIter args;
+  DBusMessage *message = NULL;
+  DBusMessage *reply = NULL;
+
+  message = dbus_message_new_method_call("org.freedesktop.ColorManager",
+                                         "/org/freedesktop/ColorManager",
+                                         "org.freedesktop.ColorManager",
+                                         "FindDeviceById");
+  dbus_message_iter_init_append(message, &args);
+  dbus_message_iter_append_basic(&args, DBUS_TYPE_STRING, &device_id);
+
+  /* send syncronous */
+  dbus_error_init(&error);
+  fprintf(stderr, "DEBUG: Calling FindDeviceById(%s)\n", device_id);
+  reply = dbus_connection_send_with_reply_and_block(con,
+                message,
+                -1,
+                &error);
+  if (reply == NULL) {
+    fprintf(stderr, "DEBUG: Failed to send: %s:%s\n",
+            error.name, error.message);
+    dbus_error_free(&error);
+    goto out;
+  }
+
+  /* get reply data */
+  dbus_message_iter_init(reply, &args);
+  if (dbus_message_iter_get_arg_type(&args) != DBUS_TYPE_OBJECT_PATH) {
+    fprintf(stderr, "DEBUG: Incorrect reply type\n");
+    goto out;
+  }
+  dbus_message_iter_get_basic(&args, &device_path_tmp);
+  fprintf(stderr, "DEBUG: Found device %s\n", device_path_tmp);
+  device_path = strdup(device_path_tmp);
+out:
+  if (message != NULL)
+    dbus_message_unref(message);
+  if (reply != NULL)
+    dbus_message_unref(reply);
+  return device_path;
+}
+
+char *
+colord_get_profile_for_device_id (const char *device_id,
+				  const char **qualifier_tuple)
+{
+  DBusConnection *con = NULL;
+  char *device_path = NULL;
+  char *filename = NULL;
+
+  if (device_id == NULL) {
+    fprintf(stderr, "DEBUG: No colord device ID available\n");
+    goto out;
+  }
+
+  /* connect to system bus */
+  con = dbus_bus_get(DBUS_BUS_SYSTEM, NULL);
+  if (con == NULL) {
+    // If D-Bus is not reachable, gracefully leave and ignore error
+    //fprintf(stderr, "ERROR: Failed to connect to system bus\n");
+    goto out;
+  }
+
+  /* find the device */
+  device_path = get_device_path_for_device_id (con, device_id);
+  if (device_path == NULL) {
+    fprintf(stderr, "DEBUG: Failed to get device %s\n", device_id);
+    goto out;
+  }
+
+  /* get the best profile for the device */
+  filename = get_profile_for_device_path(con, device_path, qualifier_tuple);
+  if (filename == NULL) {
+    fprintf(stderr, "DEBUG: Failed to get profile filename for %s\n", device_id);
+    goto out;
+  }
+  fprintf(stderr, "DEBUG: Use profile filename: '%s'\n", filename);
+out:
+  free(device_path);
+  if (con != NULL)
+    dbus_connection_unref(con);
+  return filename;
+}
+
+int
+get_profile_inhibitors (DBusConnection *con, const char *object_path)
+{
+  char *tmp;
+  const char *interface = "org.freedesktop.ColorManager.Device";
+  const char *property = "ProfilingInhibitors";
+  DBusError error;
+  DBusMessageIter args;
+  DBusMessageIter sub;
+  DBusMessageIter sub2;
+  DBusMessage *message = NULL;
+  DBusMessage *reply = NULL;
+  int inhibitors = 0;
+
+  message = dbus_message_new_method_call("org.freedesktop.ColorManager",
+                                         object_path,
+                                         "org.freedesktop.DBus.Properties",
+                                         "Get");
+
+  dbus_message_iter_init_append(message, &args);
+  dbus_message_iter_append_basic(&args, DBUS_TYPE_STRING, &interface);
+  dbus_message_iter_append_basic(&args, DBUS_TYPE_STRING, &property);
+
+  /* send syncronous */
+  dbus_error_init(&error);
+  fprintf(stderr, "DEBUG: Calling %s.Get(%s)\n", interface, property);
+  reply = dbus_connection_send_with_reply_and_block(con,
+                                                    message,
+                                                    -1,
+                                                    &error);
+  if (reply == NULL) {
+    fprintf(stderr, "DEBUG: Failed to send: %s:%s\n",
+           error.name, error.message);
+    dbus_error_free(&error);
+    goto out;
+  }
+
+  /* get reply data */
+  dbus_message_iter_init(reply, &args);
+  if (dbus_message_iter_get_arg_type(&args) != DBUS_TYPE_VARIANT) {
+    fprintf(stderr, "DEBUG: Incorrect reply type\n");
+    goto out;
+  }
+
+  /* count the size of the array */
+  dbus_message_iter_recurse(&args, &sub2);
+  dbus_message_iter_recurse(&sub2, &sub);
+  while (dbus_message_iter_get_arg_type(&sub) != DBUS_TYPE_INVALID) {
+    dbus_message_iter_get_basic(&sub, &tmp);
+    fprintf(stderr, "DEBUG: Inhibitor %s exists\n", tmp);
+    dbus_message_iter_next(&sub);
+    inhibitors++;
+  }
+out:
+  if (message != NULL)
+    dbus_message_unref(message);
+  if (reply != NULL)
+    dbus_message_unref(reply);
+  return inhibitors;
+}
+
+int
+colord_get_inhibit_for_device_id (const char *device_id)
+{
+  DBusConnection *con;
+  char *device_path = NULL;
+  int has_inhibitors = FALSE;
+
+  /* connect to system bus */
+  con = dbus_bus_get(DBUS_BUS_SYSTEM, NULL);
+  if (con == NULL) {
+    // If D-Bus is not reachable, gracefully leave and ignore error
+    //fprintf(stderr, "ERROR: Failed to connect to system bus\n");
+    goto out;
+  }
+
+  /* find the device */
+  device_path = get_device_path_for_device_id (con, device_id);
+  if (device_path == NULL) {
+    fprintf(stderr, "DEBUG: Failed to get find device %s\n", device_id);
+    goto out;
+  }
+
+  /* get the best profile for the device */
+  has_inhibitors = get_profile_inhibitors(con, device_path);
+out:
+  free(device_path);
+  if (con != NULL)
+    dbus_connection_unref(con);
+  return has_inhibitors;
+}
+
+#else
+
+char *
+colord_get_profile_for_device_id (const char *device_id,
+                                  const char **qualifier_tuple)
+{
+  fprintf(stderr, "WARN: not compiled with DBus support\n");
+  return NULL;
+}
+
+int
+colord_get_inhibit_for_device_id (const char *device_id)
+{
+  fprintf(stderr, "WARN: not compiled with DBus support\n");
+  return 0;
+}
+
+#endif
--- /dev/null
+++ ghostscript-9.26/cups/colord.h
@@ -0,0 +1,49 @@
+/*
+Copyright (c) 2011-2013, Richard Hughes
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+MIT Open Source License  -  http://www.opensource.org/
+
+*/
+
+
+#ifndef _CUPS_FILTERS_COLORD_H_
+#  define _CUPS_FILTERS_COLORD_H_
+
+#  ifdef __cplusplus
+extern "C" {
+#  endif /* __cplusplus */
+
+/* Common routines for accessing the colord CMS framework */
+
+#include <cups/raster.h>
+#include <cups/ppd.h>
+
+char  **colord_get_qualifier_for_ppd      (ppd_file_t *ppd);
+char   *colord_get_profile_for_device_id  (const char *device_id,
+                                           const char **qualifier_tuple);
+int     colord_get_inhibit_for_device_id  (const char *device_id);
+
+#  ifdef __cplusplus
+}
+#  endif /* __cplusplus */
+
+#endif /* !_CUPS_FILTERS_COLORD_H_ */
--- ghostscript-9.26/cups/cups.mak
+++ ghostscript-9.26/cups/cups.mak
@@ -35,4 +35,35 @@ cups_=	$(GLOBJ)gdevcups.$(OBJ)
 # CUPSPDFTORASTER= 1 if CUPS is new enough (cups-config --version)
 # CUPSDIR
 
-install:
+GSTORASTER_XE=$(BINDIR)$(D)gstoraster$(XE)
+
+cups: gstoraster
+
+gstoraster: $(GSTORASTER_XE)
+gstoraster_=$(LCUPSSRCDIR)$(D)gstoraster.c $(LCUPSSRCDIR)$(D)colord.c
+
+$(GSTORASTER_XE): $(gstoraster_)
+	if [ "$(CUPSPDFTORASTER)" = "1" ]; then \
+	    $(GLCC) $(LDFLAGS) $(DBUS_CFLAGS) -DBINDIR='"$(bindir)"' -DCUPSDATA='"$(CUPSDATA)"' -DGS='"$(GS)"' -o $@ $(gstoraster_) `cups-config --image --ldflags --libs` $(DBUS_LIBS); \
+	fi
+
+
+install:	install-cups
+
+install-cups: cups
+	-mkdir -p $(DESTDIR)$(CUPSSERVERBIN)/filter
+	if [ "$(CUPSPDFTORASTER)" = "1" ]; then \
+	    $(INSTALL_PROGRAM) $(GSTORASTER_XE) $(DESTDIR)$(CUPSSERVERBIN)/filter; \
+	fi
+	$(INSTALL_PROGRAM) $(LCUPSSRCDIR)$(D)gstopxl $(DESTDIR)$(CUPSSERVERBIN)/filter
+	-mkdir -p $(DESTDIR)$(CUPSSERVERROOT)
+	if [ "$(CUPSPDFTORASTER)" = "1" ]; then \
+	    $(INSTALL_DATA) $(LCUPSSRCDIR)$(D)gstoraster.convs $(DESTDIR)$(CUPSSERVERROOT); \
+	fi
+	-mkdir -p $(DESTDIR)$(CUPSDATA)/model
+	$(INSTALL_DATA) $(LCUPSSRCDIR)$(D)pxlcolor.ppd $(DESTDIR)$(CUPSDATA)/model
+	$(INSTALL_DATA) $(LCUPSSRCDIR)$(D)pxlmono.ppd $(DESTDIR)$(CUPSDATA)/model
+
+
+#
+#
--- /dev/null
+++ ghostscript-9.26/cups/gstopxl.in
@@ -0,0 +1,186 @@
+#!/bin/sh
+#
+#
+# CUPS PCL XL/PCL 6 filter script for Ghostscript.
+#
+# Copyright 2001-2005 by Easy Software Products.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+#
+
+# Installation directories...
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+bindir=@bindir@
+
+# Set the library/font path...
+GS_LIB="${CUPS_FONTPATH:=/usr/share/cups/fonts}"
+export GS_LIB
+
+# Determine the PCL XL/PCL 6 driver to use...
+if test "x$PPD" != x; then
+    colordevice=`grep '^*ColorDevice:' "$PPD" | awk -F: '{print $2}'`
+    case "$colordevice" in
+	*True* | *true*)
+	    device="pxlcolor"
+	    ;;
+	*)
+	    device="pxlmono"
+	    ;;
+    esac
+else
+    device="pxlmono"
+fi
+
+# Apply PPD settings.
+
+ps_code=
+ppd_opts=
+
+resolution=
+eval "$(printf "%s" "$5" | /usr/gnu/bin/sed @SED_EXTENDED_REGEX_OPT@ 's/.*(^|[[:space:]])Resolution=([0-9.]+(x[0-9.]+)?).*/resolution="${resolution:-\2}"/p')"
+if test -e "$PPD"; then
+  eval "$(/usr/gnu/bin/sed @SED_EXTENDED_REGEX_OPT@ 's/^\*DefaultResolution:[[:space:]]+([0-9.]+(x[0-9.]+)?).*/resolution="${resolution:-\1}"/p' "$PPD")"
+fi
+echo "DEBUG: Resolution: $resolution" >&2
+if test -n "$resolution"; then
+  ppd_opts="${ppd_opts:+$ppd_opts }-r$resolution"
+fi
+
+pagesize=
+eval "$(printf "%s" "$5" | /usr/gnu/bin/sed @SED_EXTENDED_REGEX_OPT@ 's/.*(^|[[:space:]])(media|PageSize)=([^[:space:]]+).*/pagesize="${pagesize:-\3}"/p')"
+if test -e "$PPD"; then
+  eval "$(/usr/gnu/bin/sed @SED_EXTENDED_REGEX_OPT@ 's/^\*DefaultPageSize:[[:space:]]+([^[:space:]]+).*/pagesize="${pagesize:-\1}"/p' "$PPD")"
+fi
+echo "DEBUG: Page size: $pagesize" >&2
+width=
+height=
+if test -n "$pagesize" && test -e "$PPD"; then
+  eval "$(/usr/gnu/bin/sed @SED_EXTENDED_REGEX_OPT@ 's|^\*PaperDimension[[:space:]]+'"$pagesize"'/[^:]+:[[:space:]]+"([^[:space:]]+)[[:space:]]+([^[:space:]]+)".*|width="\1"; height="\2"|p' "$PPD")"
+fi
+echo "DEBUG: Width: $width, height: $height" >&2
+if test -n "$width"; then
+  ppd_opts="${ppd_opts:+$ppd_opts }-dDEVICEWIDTHPOINTS=$width"
+fi
+if test -n "$height"; then
+  ppd_opts="${ppd_opts:+$ppd_opts }-dDEVICEHEIGHTPOINTS=$height"
+fi
+
+bl_x=
+bl_y=
+tr_x=
+tr_y=
+if test -n "$pagesize" && test -e "$PPD"; then
+  eval "$(/usr/gnu/bin/sed @SED_EXTENDED_REGEX_OPT@ 's|^\*ImageableArea[[:space:]]+'"$pagesize"'/[^:]+:[[:space:]]+"([^[:space:]]+)[[:space:]]+([^[:space:]]+)[[:space:]]+([^[:space:]]+)[[:space:]]+([^[:space:]]+)".*|bl_x="\1"; bl_y="\2"; tr_x="\3"; tr_y="\4"|p' "$PPD")"
+fi
+echo "DEBUG: Absolute margins: $bl_x, $bl_y, $tr_x, $tr_y" >&2
+margin_l=
+margin_b=
+margin_r=
+margin_t=
+if test -n "$width" && test -n "$height" && \
+   test -n "$bl_x" && test -n "$bl_y" && \
+   test -n "$tr_x" && test -n "$tr_y"; then
+  margin_l="$bl_x"
+  margin_b="$bl_y"
+  margin_r="$(printf "scale=8; (%s)-(%s)\n" "$width" "$tr_x" | bc)"
+  margin_t="$(printf "scale=8; (%s)-(%s)\n" "$height" "$tr_y" | bc)"
+fi
+echo "DEBUG: Relative margins: $margin_l, $margin_b, $margin_r, $margin_t" >&2
+if test -n "$margin_l" && test -n "$margin_b" && \
+   test -n "$margin_r" && test -n "$margin_t"; then
+  ps_code="${ps_code:+$ps_code }<</.HWMargins[$margin_l $margin_b $margin_r $margin_t] /Margins[0 0]>>setpagedevice"
+fi
+
+inputslot=
+eval "$(printf "%s" "$5" | /usr/gnu/bin/sed @SED_EXTENDED_REGEX_OPT@ 's/.*(^|[[:space:]])(InputSlot)=([^[:space:]]+).*/inputslot="${inputslot:-\3}"/p')"
+if test -e "$PPD"; then
+  eval "$(/usr/gnu/bin/sed @SED_EXTENDED_REGEX_OPT@ 's/^\*DefaultInputSlot:[[:space:]]+([^[:space:]]+).*/inputslot="${inputslot:-\1}"/p' "$PPD")"
+fi
+echo "DEBUG: InputSlot: $inputslot" >&2
+inputslot_val=
+if test -n "$inputslot" && test -e "$PPD"; then
+  eval "$(/usr/gnu/bin/sed @SED_EXTENDED_REGEX_OPT@ 's|^\*InputSlot[[:space:]]+'"$inputslot"'/[^:]+:[[:space:]]+"[[:space:]]*<[[:space:]]*<[[:space:]]*/MediaPosition[[:space:]]*([0-9]+)[[:space:]]*>[[:space:]]*>[[:space:]]*setpagedevice[[:space:]]*".*|inputslot_val="\1"|p' "$PPD")"
+fi
+echo "DEBUG: Value for MediaPosition: $inputslot_val" >&2
+if test -n "$inputslot_val"; then
+  ppd_opts="${ppd_opts:+$ppd_opts }-dMediaPosition=$inputslot_val"
+fi
+
+colormodel=
+eval "$(printf "%s" "$5" | /usr/gnu/bin/sed @SED_EXTENDED_REGEX_OPT@ 's/.*(^|[[:space:]])(ColorModel)=([^[:space:]]+).*/colormodel="${colormodel:-\3}"/p')"
+if test -e "$PPD"; then
+  eval "$(/usr/gnu/bin/sed @SED_EXTENDED_REGEX_OPT@ 's/^\*DefaultColorModel:[[:space:]]+([^[:space:]]+).*/colormodel="${colormodel:-\1}"/p' "$PPD")"
+fi
+echo "DEBUG: ColorModel: $colormodel" >&2
+if test "$colormodel" = "Gray"; then
+    device=pxlmono
+fi
+colormodel_val=
+if test -n "$colormodel" && test -e "$PPD"; then
+  eval "$(/usr/gnu/bin/sed @SED_EXTENDED_REGEX_OPT@ 's|^\*ColorModel[[:space:]]+'"$colormodel"'/[^:]+:[[:space:]]+"[[:space:]]*<[[:space:]]*<[[:space:]]*/BitsPerPixel[[:space:]]*([0-9]*)[[:space:]]*>[[:space:]]*>[[:space:]]*setpagedevice[[:space:]]*".*|colormodel_val="\1"|p' "$PPD")"
+fi
+echo "DEBUG: Value for BitsPerPixel: $colormodel_val" >&2
+if test -n "$colormodel_val"; then
+  ppd_opts="${ppd_opts:+$ppd_opts }-dBitsPerPixel=$colormodel_val"
+fi
+
+duplex=
+eval "$(printf "%s" "$5" | /usr/gnu/bin/sed @SED_EXTENDED_REGEX_OPT@ 's/.*(^|[[:space:]])(Duplex)=([^[:space:]]+).*/duplex="${duplex:-\3}"/p')"
+if test -e "$PPD"; then
+  eval "$(/usr/gnu/bin/sed @SED_EXTENDED_REGEX_OPT@ 's/^\*DefaultDuplex:[[:space:]]+([^[:space:]]+).*/duplex="${duplex:-\1}"/p' "$PPD")"
+fi
+echo "DEBUG: Duplex: $duplex" >&2
+duplex_val=
+tumble_val=
+if test -n "$duplex" && test -e "$PPD"; then
+  eval "$(/usr/gnu/bin/sed @SED_EXTENDED_REGEX_OPT@ 's|^\*Duplex[[:space:]]+'"$duplex"'/[^:]+:[[:space:]]+"[[:space:]]*<[[:space:]]*<[[:space:]]*/Duplex[[:space:]]*([^[:space:]]*)[[:space:]]*(/Tumble[[:space:]]*([^[:space:]]*)[[:space:]]*)?>[[:space:]]*>[[:space:]]*setpagedevice[[:space:]]*".*|duplex_val="\1"; tumble_val="\3"|p' "$PPD")"
+fi
+echo "DEBUG: Value for Duplex: $duplex_val; Value for Tumble: $tumble_val" >&2
+if test -n "$duplex_val"; then
+  ppd_opts="${ppd_opts:+$ppd_opts }-dDuplex=$duplex_val"
+fi
+if test -n "$tumble_val"; then
+  ppd_opts="${ppd_opts:+$ppd_opts }-dTumble=$tumble_val"
+fi
+
+
+echo "DEBUG: PPD options: $ppd_opts" >&2
+echo "DEBUG: PostScript code from options: $ps_code" >&2
+
+# Options we use with Ghostscript...
+gsopts="-dQUIET -dPARANOIDSAFER -dNOPAUSE -dBATCH -dNOINTERPOLATE"
+gsopts="$gsopts -sDEVICE=$device -sstdout=%stderr"
+
+# See if we have a filename on the command-line...
+if [ -n "$6" ]; then
+  exec <"$6"
+fi
+
+# We read the data into a temporary file as Ghostscript needs this to be
+# able to also work with PDF input
+tempfiles=
+trap 'rm -f $tempfiles' 0 1 2 13 15
+
+ifile=$(mktemp -t gstopxl.XXXXXX)
+tempfiles="$tempfiles $ifile"
+
+cat >"$ifile"
+
+echo INFO: Starting GPL Ghostscript `$bindir/@GS@ --version`... 1>&2
+echo DEBUG: Running $bindir/@GS@ $gsopts $ppd_opts -sOUTPUTFILE="%stdout" -c "$ps_code" -f "$ifile" 1>&2
+
+# Now run Ghostscript...
+$bindir/@GS@ $gsopts $ppd_opts -sOUTPUTFILE="%stdout" -c "$ps_code" -f "$ifile"
--- /dev/null
+++ ghostscript-9.26/cups/gstopxl
@@ -0,0 +1,186 @@
+#!/bin/sh
+#
+#
+# CUPS PCL XL/PCL 6 filter script for Ghostscript.
+#
+# Copyright 2001-2005 by Easy Software Products.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+#
+
+# Installation directories...
+prefix=/usr
+exec_prefix=${prefix}
+bindir=${exec_prefix}/bin
+
+# Set the library/font path...
+GS_LIB="${CUPS_FONTPATH:=/usr/share/cups/fonts}"
+export GS_LIB
+
+# Determine the PCL XL/PCL 6 driver to use...
+if test "x$PPD" != x; then
+    colordevice=`grep '^*ColorDevice:' "$PPD" | awk -F: '{print $2}'`
+    case "$colordevice" in
+	*True* | *true*)
+	    device="pxlcolor"
+	    ;;
+	*)
+	    device="pxlmono"
+	    ;;
+    esac
+else
+    device="pxlmono"
+fi
+
+# Apply PPD settings.
+
+ps_code=
+ppd_opts=
+
+resolution=
+eval "$(printf "%s" "$5" | /usr/gnu/bin/sed -nre 's/.*(^|[[:space:]])Resolution=([0-9.]+(x[0-9.]+)?).*/resolution="${resolution:-\2}"/p')"
+if test -e "$PPD"; then
+  eval "$(/usr/gnu/bin/sed -nre 's/^\*DefaultResolution:[[:space:]]+([0-9.]+(x[0-9.]+)?).*/resolution="${resolution:-\1}"/p' "$PPD")"
+fi
+echo "DEBUG: Resolution: $resolution" >&2
+if test -n "$resolution"; then
+  ppd_opts="${ppd_opts:+$ppd_opts }-r$resolution"
+fi
+
+pagesize=
+eval "$(printf "%s" "$5" | /usr/gnu/bin/sed -nre 's/.*(^|[[:space:]])(media|PageSize)=([^[:space:]]+).*/pagesize="${pagesize:-\3}"/p')"
+if test -e "$PPD"; then
+  eval "$(/usr/gnu/bin/sed -nre 's/^\*DefaultPageSize:[[:space:]]+([^[:space:]]+).*/pagesize="${pagesize:-\1}"/p' "$PPD")"
+fi
+echo "DEBUG: Page size: $pagesize" >&2
+width=
+height=
+if test -n "$pagesize" && test -e "$PPD"; then
+  eval "$(/usr/gnu/bin/sed -nre 's|^\*PaperDimension[[:space:]]+'"$pagesize"'/[^:]+:[[:space:]]+"([^[:space:]]+)[[:space:]]+([^[:space:]]+)".*|width="\1"; height="\2"|p' "$PPD")"
+fi
+echo "DEBUG: Width: $width, height: $height" >&2
+if test -n "$width"; then
+  ppd_opts="${ppd_opts:+$ppd_opts }-dDEVICEWIDTHPOINTS=$width"
+fi
+if test -n "$height"; then
+  ppd_opts="${ppd_opts:+$ppd_opts }-dDEVICEHEIGHTPOINTS=$height"
+fi
+
+bl_x=
+bl_y=
+tr_x=
+tr_y=
+if test -n "$pagesize" && test -e "$PPD"; then
+  eval "$(/usr/gnu/bin/sed -nre 's|^\*ImageableArea[[:space:]]+'"$pagesize"'/[^:]+:[[:space:]]+"([^[:space:]]+)[[:space:]]+([^[:space:]]+)[[:space:]]+([^[:space:]]+)[[:space:]]+([^[:space:]]+)".*|bl_x="\1"; bl_y="\2"; tr_x="\3"; tr_y="\4"|p' "$PPD")"
+fi
+echo "DEBUG: Absolute margins: $bl_x, $bl_y, $tr_x, $tr_y" >&2
+margin_l=
+margin_b=
+margin_r=
+margin_t=
+if test -n "$width" && test -n "$height" && \
+   test -n "$bl_x" && test -n "$bl_y" && \
+   test -n "$tr_x" && test -n "$tr_y"; then
+  margin_l="$bl_x"
+  margin_b="$bl_y"
+  margin_r="$(printf "scale=8; (%s)-(%s)\n" "$width" "$tr_x" | bc)"
+  margin_t="$(printf "scale=8; (%s)-(%s)\n" "$height" "$tr_y" | bc)"
+fi
+echo "DEBUG: Relative margins: $margin_l, $margin_b, $margin_r, $margin_t" >&2
+if test -n "$margin_l" && test -n "$margin_b" && \
+   test -n "$margin_r" && test -n "$margin_t"; then
+  ps_code="${ps_code:+$ps_code }<</.HWMargins[$margin_l $margin_b $margin_r $margin_t] /Margins[0 0]>>setpagedevice"
+fi
+
+inputslot=
+eval "$(printf "%s" "$5" | /usr/gnu/bin/sed -nre 's/.*(^|[[:space:]])(InputSlot)=([^[:space:]]+).*/inputslot="${inputslot:-\3}"/p')"
+if test -e "$PPD"; then
+  eval "$(/usr/gnu/bin/sed -nre 's/^\*DefaultInputSlot:[[:space:]]+([^[:space:]]+).*/inputslot="${inputslot:-\1}"/p' "$PPD")"
+fi
+echo "DEBUG: InputSlot: $inputslot" >&2
+inputslot_val=
+if test -n "$inputslot" && test -e "$PPD"; then
+  eval "$(/usr/gnu/bin/sed -nre 's|^\*InputSlot[[:space:]]+'"$inputslot"'/[^:]+:[[:space:]]+"[[:space:]]*<[[:space:]]*<[[:space:]]*/MediaPosition[[:space:]]*([0-9]+)[[:space:]]*>[[:space:]]*>[[:space:]]*setpagedevice[[:space:]]*".*|inputslot_val="\1"|p' "$PPD")"
+fi
+echo "DEBUG: Value for MediaPosition: $inputslot_val" >&2
+if test -n "$inputslot_val"; then
+  ppd_opts="${ppd_opts:+$ppd_opts }-dMediaPosition=$inputslot_val"
+fi
+
+colormodel=
+eval "$(printf "%s" "$5" | /usr/gnu/bin/sed -nre 's/.*(^|[[:space:]])(ColorModel)=([^[:space:]]+).*/colormodel="${colormodel:-\3}"/p')"
+if test -e "$PPD"; then
+  eval "$(/usr/gnu/bin/sed -nre 's/^\*DefaultColorModel:[[:space:]]+([^[:space:]]+).*/colormodel="${colormodel:-\1}"/p' "$PPD")"
+fi
+echo "DEBUG: ColorModel: $colormodel" >&2
+if test "$colormodel" = "Gray"; then
+    device=pxlmono
+fi
+colormodel_val=
+if test -n "$colormodel" && test -e "$PPD"; then
+  eval "$(/usr/gnu/bin/sed -nre 's|^\*ColorModel[[:space:]]+'"$colormodel"'/[^:]+:[[:space:]]+"[[:space:]]*<[[:space:]]*<[[:space:]]*/BitsPerPixel[[:space:]]*([0-9]*)[[:space:]]*>[[:space:]]*>[[:space:]]*setpagedevice[[:space:]]*".*|colormodel_val="\1"|p' "$PPD")"
+fi
+echo "DEBUG: Value for BitsPerPixel: $colormodel_val" >&2
+if test -n "$colormodel_val"; then
+  ppd_opts="${ppd_opts:+$ppd_opts }-dBitsPerPixel=$colormodel_val"
+fi
+
+duplex=
+eval "$(printf "%s" "$5" | /usr/gnu/bin/sed -nre 's/.*(^|[[:space:]])(Duplex)=([^[:space:]]+).*/duplex="${duplex:-\3}"/p')"
+if test -e "$PPD"; then
+  eval "$(/usr/gnu/bin/sed -nre 's/^\*DefaultDuplex:[[:space:]]+([^[:space:]]+).*/duplex="${duplex:-\1}"/p' "$PPD")"
+fi
+echo "DEBUG: Duplex: $duplex" >&2
+duplex_val=
+tumble_val=
+if test -n "$duplex" && test -e "$PPD"; then
+  eval "$(/usr/gnu/bin/sed -nre 's|^\*Duplex[[:space:]]+'"$duplex"'/[^:]+:[[:space:]]+"[[:space:]]*<[[:space:]]*<[[:space:]]*/Duplex[[:space:]]*([^[:space:]]*)[[:space:]]*(/Tumble[[:space:]]*([^[:space:]]*)[[:space:]]*)?>[[:space:]]*>[[:space:]]*setpagedevice[[:space:]]*".*|duplex_val="\1"; tumble_val="\3"|p' "$PPD")"
+fi
+echo "DEBUG: Value for Duplex: $duplex_val; Value for Tumble: $tumble_val" >&2
+if test -n "$duplex_val"; then
+  ppd_opts="${ppd_opts:+$ppd_opts }-dDuplex=$duplex_val"
+fi
+if test -n "$tumble_val"; then
+  ppd_opts="${ppd_opts:+$ppd_opts }-dTumble=$tumble_val"
+fi
+
+
+echo "DEBUG: PPD options: $ppd_opts" >&2
+echo "DEBUG: PostScript code from options: $ps_code" >&2
+
+# Options we use with Ghostscript...
+gsopts="-dQUIET -dPARANOIDSAFER -dNOPAUSE -dBATCH -dNOINTERPOLATE"
+gsopts="$gsopts -sDEVICE=$device -sstdout=%stderr"
+
+# See if we have a filename on the command-line...
+if [ -n "$6" ]; then
+  exec <"$6"
+fi
+
+# We read the data into a temporary file as Ghostscript needs this to be
+# able to also work with PDF input
+tempfiles=
+trap 'rm -f $tempfiles' 0 1 2 13 15
+
+ifile=$(mktemp -t gstopxl.XXXXXX)
+tempfiles="$tempfiles $ifile"
+
+cat >"$ifile"
+
+echo INFO: Starting GPL Ghostscript `$bindir/gs --version`... 1>&2
+echo DEBUG: Running $bindir/gs $gsopts $ppd_opts -sOUTPUTFILE="%stdout" -c "$ps_code" -f "$ifile" 1>&2
+
+# Now run Ghostscript...
+$bindir/gs $gsopts $ppd_opts -sOUTPUTFILE="%stdout" -c "$ps_code" -f "$ifile"
--- /dev/null
+++ ghostscript-9.26/cups/gstoraster.c
@@ -0,0 +1,735 @@
+/*
+
+Copyright (c) 2008, Till Kamppeter
+Copyright (c) 2011, Tim Waugh
+Copyright (c) 2011-2013, Richard Hughes
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+MIT Open Source License  -  http://www.opensource.org/
+
+*/
+
+
+/* PS/PDF to CUPS Raster filter based on Ghostscript */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <cups/cups.h>
+#include <stdarg.h>
+#include <fcntl.h>
+#include <cups/raster.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <signal.h>
+#include <errno.h>
+
+#include "colord.h"
+
+#define PDF_MAX_CHECK_COMMENT_LINES	20
+
+#ifndef GS
+#define GS "gs"
+#endif
+#ifndef BINDIR
+#define BINDIR "/usr/bin"
+#endif
+#ifndef CUPS_FONTPATH
+#define CUPS_FONTPATH "/usr/share/cups/fonts"
+#endif
+#ifndef CUPSDATA
+#define CUPSDATA "/usr/share/cups"
+#endif
+
+typedef enum {
+  GS_DOC_TYPE_PDF,
+  GS_DOC_TYPE_PS,
+  GS_DOC_TYPE_UNKNOWN
+} GsDocType;
+
+#ifdef CUPS_RASTER_SYNCv1
+typedef cups_page_header2_t gs_page_header;
+#else
+typedef cups_page_header_t gs_page_header;
+#endif /* CUPS_RASTER_SYNCv1 */
+
+static GsDocType
+parse_doc_type(FILE *fp)
+{
+  char buf[5];
+  GsDocType doc_type;
+  char *rc;
+
+  /* get the first few bytes of the file */
+  doc_type = GS_DOC_TYPE_UNKNOWN;
+  rewind(fp);
+  rc = fgets(buf,sizeof(buf),fp);
+  if (rc == NULL)
+    goto out;
+
+  /* is PDF */
+  if (strncmp(buf,"%PDF",4) == 0) {
+    doc_type = GS_DOC_TYPE_PDF;
+    goto out;
+  }
+
+  /* is PS */
+  if (strncmp(buf,"%!",2) == 0) {
+    doc_type = GS_DOC_TYPE_PS;
+    goto out;
+  }
+out:
+  return doc_type;
+}
+
+static void
+parse_pdf_header_options(FILE *fp, gs_page_header *h)
+{
+  char buf[4096];
+  int i;
+
+  rewind(fp);
+  /* skip until PDF start header */
+  while (fgets(buf,sizeof(buf),fp) != 0) {
+    if (strncmp(buf,"%PDF",4) == 0) {
+      break;
+    }
+  }
+  for (i = 0;i < PDF_MAX_CHECK_COMMENT_LINES;i++) {
+    if (fgets(buf,sizeof(buf),fp) == 0) break;
+    if (strncmp(buf,"%%PDFTOPDFNumCopies",19) == 0) {
+      char *p;
+
+      p = strchr(buf+19,':');
+      h->NumCopies = atoi(p+1);
+    } else if (strncmp(buf,"%%PDFTOPDFCollate",17) == 0) {
+      char *p;
+
+      p = strchr(buf+17,':');
+      while (*p == ' ' || *p == '\t') p++;
+      if (strncasecmp(p,"true",4) == 0) {
+        h->Collate = CUPS_TRUE;
+      } else {
+        h->Collate = CUPS_FALSE;
+      }
+    }
+  }
+}
+
+static void
+add_pdf_header_options(gs_page_header *h, cups_array_t *gs_args)
+{
+  int i;
+  char tmpstr[1024];
+
+  /* Simple boolean, enumerated choice, numerical, and string parameters */
+  if (h->MediaClass[0] |= '\0') {
+    snprintf(tmpstr, sizeof(tmpstr), "-sMediaClass=%s", h->MediaClass);
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->MediaColor[0] |= '\0') {
+    snprintf(tmpstr, sizeof(tmpstr), "-sMediaColor=%s", h->MediaColor);
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->MediaType[0] |= '\0') {
+    snprintf(tmpstr, sizeof(tmpstr), "-sMediaType=%s", h->MediaType);
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->OutputType[0] |= '\0') {
+    snprintf(tmpstr, sizeof(tmpstr), "-sOutputType=%s", h->OutputType);
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->AdvanceDistance) {
+    snprintf(tmpstr, sizeof(tmpstr), "-dAdvanceDistance=%d",
+	     (unsigned)(h->AdvanceDistance));
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->AdvanceMedia) {
+    snprintf(tmpstr, sizeof(tmpstr), "-dAdvanceMedia=%d",
+	     (unsigned)(h->AdvanceMedia));
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->Collate) {
+    cupsArrayAdd(gs_args, strdup("-dCollate"));
+  }
+  if (h->CutMedia) {
+    snprintf(tmpstr, sizeof(tmpstr), "-dCutMedia=%d",
+	     (unsigned)(h->CutMedia));
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->Duplex) {
+    cupsArrayAdd(gs_args, strdup("-dDuplex"));
+  }
+  if ((h->HWResolution[0] != 100) || (h->HWResolution[1] != 100))
+    snprintf(tmpstr, sizeof(tmpstr), "-r%dx%d",
+	     (unsigned)(h->HWResolution[0]), (unsigned)(h->HWResolution[1]));
+  else
+    snprintf(tmpstr, sizeof(tmpstr), "-r100x100");
+  cupsArrayAdd(gs_args, strdup(tmpstr));
+  if (h->InsertSheet) {
+    cupsArrayAdd(gs_args, strdup("-dInsertSheet"));
+  }
+  if (h->Jog) {
+    snprintf(tmpstr, sizeof(tmpstr), "-dJog=%d",
+	     (unsigned)(h->Jog));
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->LeadingEdge) {
+    snprintf(tmpstr, sizeof(tmpstr), "-dLeadingEdge=%d",
+	     (unsigned)(h->LeadingEdge));
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->ManualFeed) {
+    cupsArrayAdd(gs_args, strdup("-dManualFeed"));
+  }
+  if (h->MediaPosition) {
+    snprintf(tmpstr, sizeof(tmpstr), "-dMediaPosition=%d",
+	     (unsigned)(h->MediaPosition));
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->MediaWeight) {
+    snprintf(tmpstr, sizeof(tmpstr), "-dMediaWeight=%d",
+	     (unsigned)(h->MediaWeight));
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->MirrorPrint) {
+    cupsArrayAdd(gs_args, strdup("-dMirrorPrint"));
+  }
+  if (h->NegativePrint) {
+    cupsArrayAdd(gs_args, strdup("-dNegativePrint"));
+  }
+  if (h->NumCopies != 1) {
+    snprintf(tmpstr, sizeof(tmpstr), "-dNumCopies=%d",
+	     (unsigned)(h->NumCopies));
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->Orientation) {
+    snprintf(tmpstr, sizeof(tmpstr), "-dOrientation=%d",
+	     (unsigned)(h->Orientation));
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->OutputFaceUp) {
+    cupsArrayAdd(gs_args, strdup("-dOutputFaceUp"));
+  }
+  if (h->PageSize[0] != 612)
+    snprintf(tmpstr, sizeof(tmpstr), "-dDEVICEWIDTHPOINTS=%d",
+	     (unsigned)(h->PageSize[0]));
+  else
+    snprintf(tmpstr, sizeof(tmpstr), "-dDEVICEWIDTHPOINTS=612");
+  cupsArrayAdd(gs_args, strdup(tmpstr));
+  if (h->PageSize[1] != 792)
+    snprintf(tmpstr, sizeof(tmpstr), "-dDEVICEHEIGHTPOINTS=%d",
+	     (unsigned)(h->PageSize[1]));
+  else
+    snprintf(tmpstr, sizeof(tmpstr), "-dDEVICEHEIGHTPOINTS=792");
+  cupsArrayAdd(gs_args, strdup(tmpstr));
+  if (h->Separations) {
+    cupsArrayAdd(gs_args, strdup("-dSeparations"));
+  }
+  if (h->TraySwitch) {
+    cupsArrayAdd(gs_args, strdup("-dTraySwitch"));
+  }
+  if (h->Tumble) {
+    cupsArrayAdd(gs_args, strdup("-dTumble"));
+  }
+  if (h->cupsMediaType) {
+    snprintf(tmpstr, sizeof(tmpstr), "-dcupsMediaType=%d",
+	     (unsigned)(h->cupsMediaType));
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->cupsBitsPerColor != 1)
+    snprintf(tmpstr, sizeof(tmpstr), "-dcupsBitsPerColor=%d",
+	     (unsigned)(h->cupsBitsPerColor));
+  else
+    snprintf(tmpstr, sizeof(tmpstr), "-dcupsBitsPerColor=1");
+  cupsArrayAdd(gs_args, strdup(tmpstr));
+  if (h->cupsColorOrder != CUPS_ORDER_CHUNKED)
+    snprintf(tmpstr, sizeof(tmpstr), "-dcupsColorOrder=%d",
+	     (unsigned)(h->cupsColorOrder));
+  else
+    snprintf(tmpstr, sizeof(tmpstr), "-dcupsColorOrder=%d",
+	     CUPS_ORDER_CHUNKED);
+  cupsArrayAdd(gs_args, strdup(tmpstr));
+  if (h->cupsColorSpace != CUPS_CSPACE_K)
+    snprintf(tmpstr, sizeof(tmpstr), "-dcupsColorSpace=%d",
+	     (unsigned)(h->cupsColorSpace));
+  else
+    snprintf(tmpstr, sizeof(tmpstr), "-dcupsColorSpace=%d",
+	     CUPS_CSPACE_K);
+  cupsArrayAdd(gs_args, strdup(tmpstr));
+  if (h->cupsCompression) {
+    snprintf(tmpstr, sizeof(tmpstr), "-dcupsCompression=%d",
+	     (unsigned)(h->cupsCompression));
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->cupsRowCount) {
+    snprintf(tmpstr, sizeof(tmpstr), "-dcupsRowCount=%d",
+	     (unsigned)(h->cupsRowCount));
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->cupsRowFeed) {
+    snprintf(tmpstr, sizeof(tmpstr), "-dcupsRowFeed=%d",
+	     (unsigned)(h->cupsRowFeed));
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->cupsRowStep) {
+    snprintf(tmpstr, sizeof(tmpstr), "-dcupsRowStep=%d",
+	     (unsigned)(h->cupsRowStep));
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+#ifdef CUPS_RASTER_SYNCv1
+  if (h->cupsBorderlessScalingFactor != 1.0f) {
+    snprintf(tmpstr, sizeof(tmpstr), "-dcupsBorderlessScalingFactor=%.4f",
+	     h->cupsBorderlessScalingFactor);
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  for (i=0; i <= 15; i ++)
+    if (h->cupsInteger[i]) {
+      snprintf(tmpstr, sizeof(tmpstr), "-dcupsInteger%d=%d",
+	       i, (unsigned)(h->cupsInteger[i]));
+      cupsArrayAdd(gs_args, strdup(tmpstr));
+    }
+  for (i=0; i <= 15; i ++)
+    if (h->cupsReal[i]) {
+      snprintf(tmpstr, sizeof(tmpstr), "-dcupsReal%d=%.4f",
+	       i, h->cupsReal[i]);
+      cupsArrayAdd(gs_args, strdup(tmpstr));
+    }
+  for (i=0; i <= 15; i ++)
+    if (h->cupsString[i][0] != '\0') {
+      snprintf(tmpstr, sizeof(tmpstr), "-scupsString%d=%s",
+	       i, h->cupsString[i]);
+      cupsArrayAdd(gs_args, strdup(tmpstr));
+    }
+  if (h->cupsMarkerType[0] != '\0') {
+    snprintf(tmpstr, sizeof(tmpstr), "-scupsMarkerType=%s",
+	     h->cupsMarkerType);
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->cupsRenderingIntent[0] != '\0') {
+    snprintf(tmpstr, sizeof(tmpstr), "-scupsRenderingIntent=%s",
+	     h->cupsRenderingIntent);
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+  if (h->cupsPageSizeName[0] != '\0') {
+    snprintf(tmpstr, sizeof(tmpstr), "-scupsPageSizeName=%s",
+	     h->cupsPageSizeName);
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+#endif /* CUPS_RASTER_SYNCv1 */
+}
+
+static int
+gs_spawn (const char *filename,
+          cups_array_t *gs_args,
+          char **envp,
+          FILE *fp)
+{
+  char *argument;
+  char buf[BUFSIZ];
+  char **gsargv;
+  const char* apos;
+  int fds[2];
+  int i;
+  int n;
+  int numargs;
+  int pid;
+  int status = 1;
+
+  /* Put Ghostscript command line argument into an array for the "exec()"
+     call */
+  numargs = cupsArrayCount(gs_args);
+  gsargv = calloc(numargs + 1, sizeof(char *));
+  for (argument = (char *)cupsArrayFirst(gs_args), i = 0; argument;
+       argument = (char *)cupsArrayNext(gs_args), i++) {
+    gsargv[i] = argument;
+  }
+  gsargv[i] = NULL;
+
+  /* Debug output: Full Ghostscript command line and environment variables */
+  fprintf(stderr, "DEBUG: Ghostscript command line:");
+  for (i = 0; gsargv[i]; i ++) {
+    if ((strchr(gsargv[i],' ')) || (strchr(gsargv[i],'\t')))
+      apos = "'";
+    else
+      apos = "";
+    fprintf(stderr, " %s%s%s", apos, gsargv[i], apos);
+  }
+  fprintf(stderr, "\n");
+
+  for (i = 0; envp[i]; i ++)
+    fprintf(stderr, "DEBUG: envp[%d]=\"%s\"\n", i, envp[i]);
+
+  /* Create a pipe for feeding the job into Ghostscript */
+  if (pipe(fds))
+  {
+    fds[0] = -1;
+    fds[1] = -1;
+    fprintf(stderr, "ERROR: Unable to establish pipe for Ghostscript call\n");
+    goto out;
+  }
+
+  /* Set the "close on exec" flag on each end of the pipe... */
+  if (fcntl(fds[0], F_SETFD, fcntl(fds[0], F_GETFD) | FD_CLOEXEC))
+  {
+    close(fds[0]);
+    close(fds[1]);
+    fds[0] = -1;
+    fds[1] = -1;
+    fprintf(stderr, "ERROR: Unable to set \"close on exec\" flag on read end of the pipe for Ghostscript call\n");
+    goto out;
+  }
+  if (fcntl(fds[1], F_SETFD, fcntl(fds[1], F_GETFD) | FD_CLOEXEC))
+  {
+    close(fds[0]);
+    close(fds[1]);
+    fprintf(stderr, "ERROR: Unable to set \"close on exec\" flag on write end of the pipe for Ghostscript call\n");
+    goto out;
+  }
+
+  if ((pid = fork()) == 0)
+  {
+    /* Couple pipe with STDIN of Ghostscript process */
+    if (fds[0] != 0) {
+      close(0);
+      if (fds[0] > 0)
+        dup(fds[0]);
+      else {
+        fprintf(stderr, "ERROR: Unable to couple pipe with STDIN of Ghostscript process\n");
+        goto out;
+      }
+    }
+
+    /* Execute Ghostscript command line ... */
+    execve(filename, gsargv, envp);
+    perror(filename);
+    goto out;
+  }
+
+  /* Feed job data into Ghostscript */
+  while ((n = fread(buf, 1, BUFSIZ, fp)) > 0) {
+    int count = write(fds[1], buf, n);
+    if (count != n) {
+      if (count == -1)
+        fprintf(stderr, "ERROR: write failed: %s\n", strerror(errno));
+      fprintf(stderr, "ERROR: Can't feed job data into Ghostscript\n");
+      goto out;
+    }
+  }
+  close (fds[1]);
+
+  if (waitpid (pid, &status, 0) == -1) {
+    perror ("gs");
+    goto out;
+  }
+out:
+  free(gsargv);
+  return status;
+}
+
+static char *
+get_ppd_icc_fallback (ppd_file_t *ppd, char **qualifier)
+{
+  char full_path[1024];
+  char *icc_profile = NULL;
+  char qualifer_tmp[1024];
+  const char *profile_key;
+  ppd_attr_t *attr;
+
+  /* get profile attr, falling back to CUPS */
+  profile_key = "APTiogaProfile";
+  attr = ppdFindAttr(ppd, profile_key, NULL);
+  if (attr == NULL) {
+    profile_key = "cupsICCProfile";
+    attr = ppdFindAttr(ppd, profile_key, NULL);
+  }
+
+  /* create a string for a quick comparion */
+  snprintf(qualifer_tmp, sizeof(qualifer_tmp),
+           "%s.%s.%s",
+           qualifier[0],
+           qualifier[1],
+           qualifier[2]);
+
+  /* neither */
+  if (attr == NULL) {
+    fprintf(stderr, "INFO: no profiles specified in PPD\n");
+    goto out;
+  }
+
+  /* try to find a profile that matches the qualifier exactly */
+  for (;attr != NULL; attr = ppdFindNextAttr(ppd, profile_key, NULL)) {
+    fprintf(stderr, "INFO: found profile %s in PPD with qualifier '%s'\n",
+            attr->value, attr->spec);
+
+    /* invalid entry */
+    if (attr->spec == NULL || attr->value == NULL)
+      continue;
+
+    /* expand to a full path if not already specified */
+    if (attr->value[0] != '/')
+      snprintf(full_path, sizeof(full_path),
+               "%s/profiles/%s", CUPSDATA, attr->value);
+    else
+      strncpy(full_path, attr->value, sizeof(full_path));
+
+    /* check the file exists */
+    if (access(full_path, 0)) {
+      fprintf(stderr, "INFO: found profile %s in PPD that does not exist\n",
+              full_path);
+      continue;
+    }
+
+    /* matches the qualifier */
+    if (strcmp(qualifer_tmp, attr->spec) == 0) {
+      icc_profile = strdup(full_path);
+      goto out;
+    }
+  }
+
+  /* no match */
+  if (attr == NULL) {
+    fprintf(stderr, "INFO: no profiles in PPD for qualifier '%s'\n",
+            qualifer_tmp);
+    goto out;
+  }
+
+out:
+  return icc_profile;
+}
+
+static void
+child_reaper (int signum)
+{
+  wait(NULL);
+}
+
+int
+main (int argc, char **argv, char *envp[])
+{
+  char buf[BUFSIZ];
+  char *icc_profile = NULL;
+  char **qualifier = NULL;
+  char *tmp;
+  char tmpstr[1024];
+  const char *t = NULL;
+  cups_array_t *gs_args = NULL;
+  cups_option_t *options = NULL;
+  FILE *fp = NULL;
+  GsDocType doc_type;
+  gs_page_header h;
+  int fd;
+  int device_inhibited;
+  int i;
+  int n;
+  int num_options;
+  int status = 1;
+  ppd_file_t *ppd = NULL;
+  struct sigaction sa;
+
+  if (argc < 6 || argc > 7) {
+    fprintf(stderr, "ERROR: %s job-id user title copies options [file]\n",
+      argv[0]);
+    goto out;
+  }
+
+  memset(&sa, 0, sizeof(sa));
+  /* Ignore SIGPIPE and have write return an error instead */
+  sa.sa_handler = SIG_IGN;
+  sigaction(SIGPIPE, &sa, NULL);
+
+  sa.sa_handler = child_reaper;
+  sigaction(SIGCHLD, &sa, NULL);
+
+  num_options = cupsParseOptions(argv[5], 0, &options);
+
+  t = getenv("PPD");
+  if ((ppd = ppdOpenFile(t)) == NULL) {
+    fprintf(stderr, "ERROR: Failed to open PPD: %s\n", t);
+    goto out;
+  }
+
+  ppdMarkDefaults (ppd);
+  cupsMarkOptions (ppd, num_options, options);
+
+  if (argc == 6) {
+    /* stdin */
+
+    fd = cupsTempFd(buf,BUFSIZ);
+    if (fd < 0) {
+      fprintf(stderr, "ERROR: Can't create temporary file\n");
+      goto out;
+    }
+    /* remove name */
+    unlink(buf);
+
+    /* copy stdin to the tmp file */
+    while ((n = read(0,buf,BUFSIZ)) > 0) {
+      if (write(fd,buf,n) != n) {
+        fprintf(stderr, "ERROR: Can't copy stdin to temporary file\n");
+        close(fd);
+        goto out;
+      }
+    }
+    if (lseek(fd,0,SEEK_SET) < 0) {
+        fprintf(stderr, "ERROR: Can't rewind temporary file\n");
+        close(fd);
+        goto out;
+    }
+
+    if ((fp = fdopen(fd,"rb")) == 0) {
+        fprintf(stderr, "ERROR: Can't fdopen temporary file\n");
+        close(fd);
+        goto out;
+    }
+  } else {
+    /* argc == 7 filename is specified */
+
+    if ((fp = fopen(argv[6],"rb")) == 0) {
+        fprintf(stderr, "ERROR: Can't open input file %s\n",argv[6]);
+        goto out;
+    }
+  }
+
+  /* find out file type */
+  doc_type = parse_doc_type(fp);
+  if (doc_type == GS_DOC_TYPE_UNKNOWN) {
+    fprintf(stderr, "ERROR: Can't detect file type\n");
+    goto out;
+  }
+
+  /* support colord and the "color-management=off" option */
+  snprintf (tmpstr, sizeof(tmpstr), "cups-%s", getenv("PRINTER"));
+  device_inhibited = colord_get_inhibit_for_device_id (tmpstr);
+  t = cupsGetOption("color-management", num_options, options);
+  if (t != NULL && strcmp(t, "off") == 0)
+    device_inhibited = 1;
+  if (device_inhibited)
+    fprintf(stderr, "DEBUG: Device is inhibited, no CM performed\n");
+  qualifier = colord_get_qualifier_for_ppd (ppd);
+  if (qualifier != NULL) {
+
+    fprintf(stderr, "DEBUG: PPD uses qualifier '%s.%s.%s'\n",
+            qualifier[0], qualifier[1], qualifier[2]);
+
+    snprintf (tmpstr, sizeof(tmpstr), "cups-%s", getenv("PRINTER"));
+    icc_profile = colord_get_profile_for_device_id (tmpstr,
+                                                    (const char**) qualifier);
+
+    /* fall back to the PPD */
+    if (icc_profile == NULL)
+      icc_profile = get_ppd_icc_fallback (ppd, qualifier);
+
+    if(icc_profile != NULL)
+      fprintf(stderr, "DEBUG: Using ICC Profile '%s'\n", icc_profile);
+  }
+
+  /* Ghostscript parameters */
+  gs_args = cupsArrayNew(NULL, NULL);
+  if (!gs_args) {
+    fprintf(stderr, "ERROR: Unable to allocate memory for Ghostscript arguments array\n");
+    exit(1);
+  }
+
+  /* Part of Ghostscript command line which is not dependent on the job and/or
+     the driver */
+  snprintf(tmpstr, sizeof(tmpstr), "%s/%s", BINDIR, GS);
+  cupsArrayAdd(gs_args, strdup(tmpstr));
+  cupsArrayAdd(gs_args, strdup("-dQUIET"));
+  /*cupsArrayAdd(gs_args, strdup("-dDEBUG"));*/
+  cupsArrayAdd(gs_args, strdup("-dPARANOIDSAFER"));
+  cupsArrayAdd(gs_args, strdup("-dNOPAUSE"));
+  cupsArrayAdd(gs_args, strdup("-dBATCH"));
+  cupsArrayAdd(gs_args, strdup("-dNOINTERPOLATE"));
+  if (doc_type == GS_DOC_TYPE_PS)
+    cupsArrayAdd(gs_args, strdup("-dNOMEDIAATTRS"));
+  if (device_inhibited)
+    cupsArrayAdd(gs_args, strdup("-dUseFastColor"));
+  cupsArrayAdd(gs_args, strdup("-sDEVICE=cups"));
+  cupsArrayAdd(gs_args, strdup("-sstdout=%stderr"));
+  cupsArrayAdd(gs_args, strdup("-sOutputFile=%stdout"));
+
+  cupsRasterInterpretPPD(&h,ppd,num_options,options,0);
+
+  /* setPDF specific options */
+  if (doc_type == GS_DOC_TYPE_PDF) {
+    parse_pdf_header_options(fp, &h);
+  }
+
+  /* fixed other values that pdftopdf handles */
+  h.MirrorPrint = CUPS_FALSE;
+  h.Orientation = CUPS_ORIENT_0;
+
+  /* get all the data from the header and pass it to ghostscript */
+  add_pdf_header_options (&h, gs_args);
+
+  /* CUPS font path */
+  if ((t = getenv("CUPS_FONTPATH")) == NULL)
+    t = CUPS_FONTPATH;
+  snprintf(tmpstr, sizeof(tmpstr), "-I%s", t);
+  cupsArrayAdd(gs_args, strdup(tmpstr));
+
+  /* set the device output ICC profile */
+  if(icc_profile != NULL && icc_profile[0] != '\0') {
+    snprintf(tmpstr, sizeof(tmpstr), "-sOutputICCProfile=%s", icc_profile);
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+
+  /* Switch to taking PostScript commands on the Ghostscript command line */
+  cupsArrayAdd(gs_args, strdup("-c"));
+
+  if ((t = cupsGetOption("profile", num_options, options)) != NULL) {
+    snprintf(tmpstr, sizeof(tmpstr), "<</cupsProfile(%s)>>setpagedevice", t);
+    cupsArrayAdd(gs_args, strdup(tmpstr));
+  }
+
+  /* Mark the end of PostScript commands supplied on the Ghostscript command
+     line (with the "-c" option), so that we can supply the input file name */
+  cupsArrayAdd(gs_args, strdup("-f"));
+
+  /* Let Ghostscript read from STDIN */
+  cupsArrayAdd(gs_args, strdup("-_"));
+
+  /* Execute Ghostscript command line ... */
+  snprintf(tmpstr, sizeof(tmpstr), "%s/%s", BINDIR, GS);
+
+  /* call Ghostscript */
+  rewind(fp);
+  status = gs_spawn (tmpstr, gs_args, envp, fp);
+out:
+  if (fp)
+    fclose(fp);
+  if (qualifier != NULL) {
+    for (i=0; qualifier[i] != NULL; i++)
+      free(qualifier[i]);
+    free(qualifier);
+  }
+  if (gs_args) {
+    while ((tmp = cupsArrayFirst(gs_args)) != NULL) {
+      cupsArrayRemove(gs_args,tmp);
+      free(tmp);
+    }
+    cupsArrayDelete(gs_args);
+  }
+  free(icc_profile);
+  if (ppd)
+    ppdClose(ppd);
+  return status;
+}
--- ghostscript-9.26/cups/gstoraster.convs
+++ ghostscript-9.26/cups/gstoraster.convs
@@ -0,0 +1,30 @@
+# Copyright (c) 2008, Till Kamppeter
+# Copyright (c) 2011, Richard Hughes
+#
+# Permission is hereby granted, free of charge, to any person obtaining
+# a copy of this software and associated documentation files (the
+# "Software"), to deal in the Software without restriction, including
+# without limitation the rights to use, copy, modify, merge, publish,
+# distribute, sublicense, and/or sell copies of the Software, and to
+# permit persons to whom the Software is furnished to do so, subject to
+# the following conditions:
+#
+# The above copyright notice and this permission notice shall be included
+# in all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+#
+# MIT Open Source License  -  http://www.opensource.org/
+#
+# $Id: pdftoraster.convs 8803 2008-06-24 14:16:29Z till $
+#
+# CUPS file conversion rules for gstoraster filter
+
+application/vnd.cups-pdf	application/vnd.cups-raster	66	gstoraster
+application/vnd.cups-postscript	application/vnd.cups-raster	100	gstoraster
--- /dev/null
+++ ghostscript-9.26/cups/pxlcolor.ppd
@@ -0,0 +1,215 @@
+*PPD-Adobe: "4.3"
+*%
+*%
+*%   Sample color PCL XL/PCL 6 driver PPD file for the Common UNIX
+*%   Printing System (CUPS).
+*%
+*%   Copyright 1997-2005 by Easy Software Products.
+*%
+*%   These coded instructions, statements, and computer programs are the
+*%   property of Easy Software Products and are protected by Federal
+*%   copyright law.  Distribution and use rights are outlined in the file
+*%   "LICENSE.txt" which should have been included with this file.  If this
+*%   file is missing or damaged please contact Easy Software Products
+*%   at:
+*%
+*%       Attn: CUPS Licensing Information
+*%       Easy Software Products
+*%       44141 Airport View Drive, Suite 204
+*%       Hollywood, Maryland 20636 USA
+*%
+*%       Voice: (301) 373-9600
+*%       EMail: cups-info@cups.org
+*%         WWW: http://www.cups.org
+*%
+*FormatVersion:	"4.3"
+*FileVersion:	"1.1"
+*LanguageVersion: English 
+*LanguageEncoding: ISOLatin1
+*PCFileName:	"PXLCOLOR.PPD"
+*Manufacturer:	"HP"
+*Product:	"(GPL Ghostscript)"
+*cupsVersion:	1.1
+*cupsManualCopies: False
+*cupsFilter:	"application/vnd.cups-postscript 100 gstopxl"
+*cupsFilter:	"application/vnd.cups-pdf 0 gstopxl"
+*ModelName:     "HP Color LaserJet Series PCL 6"
+*ShortNickName: "HP Color LaserJet Series PCL 6"
+*NickName:      "HP Color LaserJet Series PCL 6 CUPS"
+*PSVersion:	"(3010.000) 86000"
+*LanguageLevel:	"3"
+*ColorDevice:	True
+*DefaultColorSpace: RGB
+*FileSystem:	False
+*Throughput:	"8"
+*LandscapeOrientation: Plus90
+*TTRasterizer:	Type42
+
+*UIConstraints: *PageSize Executive *InputSlot Envelope
+*UIConstraints: *PageSize Letter *InputSlot Envelope
+*UIConstraints: *PageSize Legal *InputSlot Envelope
+*UIConstraints: *PageSize Tabloid *InputSlot Envelope
+*UIConstraints: *PageSize A3 *InputSlot Envelope
+*UIConstraints: *PageSize A4 *InputSlot Envelope
+*UIConstraints: *PageSize A5 *InputSlot Envelope
+*UIConstraints: *PageSize B5 *InputSlot Envelope
+*UIConstraints:	*Duplex *OptionDuplex False
+*UIConstraints: *InputSlot Envelope *PageSize Executive
+*UIConstraints: *InputSlot Envelope *PageSize Letter
+*UIConstraints: *InputSlot Envelope *PageSize Legal
+*UIConstraints: *InputSlot Envelope *PageSize Tabloid
+*UIConstraints: *InputSlot Envelope *PageSize A3
+*UIConstraints: *InputSlot Envelope *PageSize A4
+*UIConstraints: *InputSlot Envelope *PageSize A5
+*UIConstraints: *InputSlot Envelope *PageSize B5
+*UIConstraints:	*OptionDuplex False *Duplex
+
+*OpenUI *PageSize/Media Size: PickOne
+*OrderDependency: 10 AnySetup *PageSize
+*DefaultPageSize: Letter
+*PageSize Letter/US Letter:	"<</PageSize[612 792]/ImagingBBox null>>setpagedevice"
+*PageSize Legal/US Legal:	"<</PageSize[612 1008]/ImagingBBox null>>setpagedevice"
+*PageSize Executive/US Executive: "<</PageSize[522 756]/ImagingBBox null>>setpagedevice"
+*PageSize Tabloid/US Tabloid:	"<</PageSize[792 1224]/ImagingBBox null>>setpagedevice"
+*PageSize A3/A3:		"<</PageSize[842 1191]/ImagingBBox null>>setpagedevice"
+*PageSize A4/A4:		"<</PageSize[595 842]/ImagingBBox null>>setpagedevice"
+*PageSize A5/A5:		"<</PageSize[421 595]/ImagingBBox null>>setpagedevice"
+*PageSize B5/B5 (JIS):		"<</PageSize[516 729]/ImagingBBox null>>setpagedevice"
+*PageSize EnvISOB5/Envelope B5: "<</PageSize[499 709]/ImagingBBox null>>setpagedevice"
+*PageSize Env10/Envelope #10:	"<</PageSize[297 684]/ImagingBBox null>>setpagedevice"
+*PageSize EnvC5/Envelope C5:	"<</PageSize[459 649]/ImagingBBox null>>setpagedevice"
+*PageSize EnvDL/Envelope DL:	"<</PageSize[312 624]/ImagingBBox null>>setpagedevice"
+*PageSize EnvMonarch/Envelope Monarch: "<</PageSize[279 540]/ImagingBBox null>>setpagedevice"
+*CloseUI: *PageSize
+
+*OpenUI *PageRegion: PickOne
+*OrderDependency: 10 AnySetup *PageRegion
+*DefaultPageRegion: Letter
+*PageRegion Letter/US Letter:	"<</PageSize[612 792]/ImagingBBox null>>setpagedevice"
+*PageRegion Legal/US Legal:	"<</PageSize[612 1008]/ImagingBBox null>>setpagedevice"
+*PageRegion Executive/US Executive: "<</PageSize[522 756]/ImagingBBox null>>setpagedevice"
+*PageRegion Tabloid/US Tabloid:	"<</PageSize[792 1224]/ImagingBBox null>>setpagedevice"
+*PageRegion A3/A3:		"<</PageSize[842 1191]/ImagingBBox null>>setpagedevice"
+*PageRegion A4/A4:		"<</PageSize[595 842]/ImagingBBox null>>setpagedevice"
+*PageRegion A5/A5:		"<</PageSize[421 595]/ImagingBBox null>>setpagedevice"
+*PageRegion B5/B5 (JIS):	"<</PageSize[516 729]/ImagingBBox null>>setpagedevice"
+*PageRegion EnvISOB5/Envelope B5: "<</PageSize[499 709]/ImagingBBox null>>setpagedevice"
+*PageRegion Env10/Envelope #10:	"<</PageSize[297 684]/ImagingBBox null>>setpagedevice"
+*PageRegion EnvC5/Envelope C5:	"<</PageSize[459 649]/ImagingBBox null>>setpagedevice"
+*PageRegion EnvDL/Envelope DL:	"<</PageSize[312 624]/ImagingBBox null>>setpagedevice"
+*PageRegion EnvMonarch/Envelope Monarch: "<</PageSize[279 540]/ImagingBBox null>>setpagedevice"
+*CloseUI: *PageRegion
+
+*DefaultImageableArea: Letter 
+*ImageableArea Letter/US Letter:	"12 12 600 780"
+*ImageableArea Legal/US Legal:		"12 12 600 996"
+*ImageableArea Executive/US Executive:	"12 12 510 708"
+*ImageableArea Tabloid/US Tabloid:	"12 12 780 1212"
+*ImageableArea A3/A3:			"12 12 830 1179"
+*ImageableArea A4/A4:			"12 12 583 830"
+*ImageableArea A5/A5:			"12 12 409 583"
+*ImageableArea B5/JIS B5:		"12 12 504 717"
+*ImageableArea EnvISOB5/B5 (ISO):	"12 12 469 697"
+*ImageableArea Env10/Com-10:		"12 12 285 672"
+*ImageableArea EnvC5/EnvC5:		"12 12 447 637"
+*ImageableArea EnvDL/EnvDL:		"12 12 300 612"
+*ImageableArea EnvMonarch/Envelope Monarch: "12 12 267 528"
+
+*DefaultPaperDimension: Letter
+*PaperDimension Letter/US Letter:	"612 792"
+*PaperDimension Legal/US Legal:		"612 1008"
+*PaperDimension Executive/US Executive:	"522 756"
+*PaperDimension Tabloid/US Tabloid:	"792 1224"
+*PaperDimension A3/A3:			"842 1191"
+*PaperDimension A4/A4:			"595 842"
+*PaperDimension A5/A5:			"421 595"
+*PaperDimension B5/B5 (JIS):		"516 729"
+*PaperDimension EnvISOB5/Envelope B5:	"499 709"
+*PaperDimension Env10/Envelope #10:	"297 684"
+*PaperDimension EnvC5/Envelope C5:	"459 649"
+*PaperDimension EnvDL/Envelope DL:	"312 624"
+*PaperDimension EnvMonarch/Envelope Monarch: "279 540"
+
+*OpenUI *InputSlot/Media Source: PickOne
+*OrderDependency: 10 AnySetup *InputSlot
+*DefaultInputSlot: Default
+*InputSlot Default/Default: "<</MediaPosition 0>>setpagedevice"
+*InputSlot Auto/Automatically Select: "<</MediaPosition 1>>setpagedevice"
+*InputSlot MultiPurpose/Tray 1: "<</MediaPosition 3>>setpagedevice"
+*InputSlot Upper/Tray 2: "<</MediaPosition 4>>setpagedevice"
+*InputSlot Lower/Tray 3: "<</MediaPosition 5>>setpagedevice"
+*InputSlot LargeCapacity/Tray 4: "<</MediaPosition 7>>setpagedevice"
+*InputSlot Manual/Manual Feed: "<</MediaPosition 2>>setpagedevice"
+*InputSlot Envelope/Envelope Feed: "<</MediaPosition 6>>setpagedevice"
+*CloseUI: *InputSlot
+
+*OpenUI *ColorModel/Output Mode: PickOne
+*OrderDependency: 10 AnySetup *ColorModel
+*DefaultColorModel: RGB
+*ColorModel RGB/Color: "<</BitsPerPixel 24>>setpagedevice"
+*ColorModel Gray/Grayscale: "<</BitsPerPixel 8>>setpagedevice"
+*CloseUI: *ColorModel
+
+*OpenUI *Resolution/Output Resolution: PickOne
+*OrderDependency: 20 AnySetup *Resolution
+*DefaultResolution: 600dpi
+*Resolution 150dpi/150 DPI: "<</HWResolution[150 150]>>setpagedevice"
+*Resolution 300dpi/300 DPI: "<</HWResolution[300 300]>>setpagedevice"
+*Resolution 600dpi/600 DPI: "<</HWResolution[600 600]>>setpagedevice"
+*Resolution 1200dpi/1200 DPI: "<</HWResolution[1200 1200]>>setpagedevice"
+*CloseUI: *Resolution
+
+*OpenUI *Duplex/Double-Sided Printing: PickOne
+*OrderDependency: 20 AnySetup *Duplex
+*DefaultDuplex: None
+*Duplex None/Off:	"<</Duplex false>>setpagedevice"
+*Duplex DuplexNoTumble/Long Edge (Standard):	"<</Duplex true/Tumble false>>setpagedevice"
+*Duplex DuplexTumble/Short Edge (Flip):	"<</Duplex true/Tumble true>>setpagedevice"
+*CloseUI:	*Duplex
+
+*OpenGroup: InstallableOptions
+*OpenUI *OptionDuplex/Duplexer: Boolean
+*DefaultOptionDuplex: False
+*OptionDuplex True/Installed:	""
+*OptionDuplex False/Not Installed:	""
+*CloseUI: *OptionDuplex
+*CloseGroup: InstallableOptions
+
+*DefaultFont: Courier
+*Font AvantGarde-Book: Standard "(001.006S)" Standard ROM
+*Font AvantGarde-BookOblique: Standard "(001.006S)" Standard ROM
+*Font AvantGarde-Demi: Standard "(001.007S)" Standard ROM
+*Font AvantGarde-DemiOblique: Standard "(001.007S)" Standard ROM
+*Font Bookman-Demi: Standard "(001.004S)" Standard ROM
+*Font Bookman-DemiItalic: Standard "(001.004S)" Standard ROM
+*Font Bookman-Light: Standard "(001.004S)" Standard ROM
+*Font Bookman-LightItalic: Standard "(001.004S)" Standard ROM
+*Font Courier: Standard "(002.004S)" Standard ROM
+*Font Courier-Bold: Standard "(002.004S)" Standard ROM
+*Font Courier-BoldOblique: Standard "(002.004S)" Standard ROM
+*Font Courier-Oblique: Standard "(002.004S)" Standard ROM
+*Font Helvetica: Standard "(001.006S)" Standard ROM
+*Font Helvetica-Bold: Standard "(001.007S)" Standard ROM
+*Font Helvetica-BoldOblique: Standard "(001.007S)" Standard ROM
+*Font Helvetica-Narrow: Standard "(001.006S)" Standard ROM
+*Font Helvetica-Narrow-Bold: Standard "(001.007S)" Standard ROM
+*Font Helvetica-Narrow-BoldOblique: Standard "(001.007S)" Standard ROM
+*Font Helvetica-Narrow-Oblique: Standard "(001.006S)" Standard ROM
+*Font Helvetica-Oblique: Standard "(001.006S)" Standard ROM
+*Font NewCenturySchlbk-Bold: Standard "(001.009S)" Standard ROM
+*Font NewCenturySchlbk-BoldItalic: Standard "(001.007S)" Standard ROM
+*Font NewCenturySchlbk-Italic: Standard "(001.006S)" Standard ROM
+*Font NewCenturySchlbk-Roman: Standard "(001.007S)" Standard ROM
+*Font Palatino-Bold: Standard "(001.005S)" Standard ROM
+*Font Palatino-BoldItalic: Standard "(001.005S)" Standard ROM
+*Font Palatino-Italic: Standard "(001.005S)" Standard ROM
+*Font Palatino-Roman: Standard "(001.005S)" Standard ROM
+*Font Symbol: Special "(001.007S)" Special ROM
+*Font Times-Bold: Standard "(001.007S)" Standard ROM
+*Font Times-BoldItalic: Standard "(001.009S)" Standard ROM
+*Font Times-Italic: Standard "(001.007S)" Standard ROM
+*Font Times-Roman: Standard "(001.007S)" Standard ROM
+*Font ZapfChancery-MediumItalic: Standard "(001.007S)" Standard ROM
+*Font ZapfDingbats: Special "(001.004S)" Standard ROM
+*%
+*%
--- /dev/null
+++ ghostscript-9.26/cups/pxlmono.ppd
@@ -0,0 +1,208 @@
+*PPD-Adobe: "4.3"
+*%
+*%
+*%   Sample monochrome PCL XL/PCL 6 driver PPD file for the Common UNIX
+*%   Printing System (CUPS).
+*%
+*%   Copyright 1997-2005 by Easy Software Products.
+*%
+*%   These coded instructions, statements, and computer programs are the
+*%   property of Easy Software Products and are protected by Federal
+*%   copyright law.  Distribution and use rights are outlined in the file
+*%   "LICENSE.txt" which should have been included with this file.  If this
+*%   file is missing or damaged please contact Easy Software Products
+*%   at:
+*%
+*%       Attn: CUPS Licensing Information
+*%       Easy Software Products
+*%       44141 Airport View Drive, Suite 204
+*%       Hollywood, Maryland 20636 USA
+*%
+*%       Voice: (301) 373-9600
+*%       EMail: cups-info@cups.org
+*%         WWW: http://www.cups.org
+*%
+*FormatVersion:	"4.3"
+*FileVersion:	"1.1"
+*LanguageVersion: English 
+*LanguageEncoding: ISOLatin1
+*PCFileName:	"PXLMONO.PPD"
+*Manufacturer:	"HP"
+*Product:	"(GPL Ghostscript)"
+*cupsVersion:	1.1
+*cupsManualCopies: False
+*cupsFilter:	"application/vnd.cups-postscript 100 gstopxl"
+*cupsFilter:	"application/vnd.cups-pdf 0 gstopxl"
+*ModelName:     "HP LaserJet Series PCL 6"
+*ShortNickName: "HP LaserJet Series PCL 6"
+*NickName:      "HP LaserJet Series PCL 6 CUPS"
+*PSVersion:	"(3010.000) 86000"
+*LanguageLevel:	"3"
+*ColorDevice:	False
+*DefaultColorSpace: Gray
+*FileSystem:	False
+*Throughput:	"8"
+*LandscapeOrientation: Plus90
+*TTRasterizer:	Type42
+
+*UIConstraints: *PageSize Executive *InputSlot Envelope
+*UIConstraints: *PageSize Letter *InputSlot Envelope
+*UIConstraints: *PageSize Legal *InputSlot Envelope
+*UIConstraints: *PageSize Tabloid *InputSlot Envelope
+*UIConstraints: *PageSize A3 *InputSlot Envelope
+*UIConstraints: *PageSize A4 *InputSlot Envelope
+*UIConstraints: *PageSize A5 *InputSlot Envelope
+*UIConstraints: *PageSize B5 *InputSlot Envelope
+*UIConstraints:	*Duplex *OptionDuplex False
+*UIConstraints: *InputSlot Envelope *PageSize Executive
+*UIConstraints: *InputSlot Envelope *PageSize Letter
+*UIConstraints: *InputSlot Envelope *PageSize Legal
+*UIConstraints: *InputSlot Envelope *PageSize Tabloid
+*UIConstraints: *InputSlot Envelope *PageSize A3
+*UIConstraints: *InputSlot Envelope *PageSize A4
+*UIConstraints: *InputSlot Envelope *PageSize A5
+*UIConstraints: *InputSlot Envelope *PageSize B5
+*UIConstraints:	*OptionDuplex False *Duplex
+
+*OpenUI *PageSize/Media Size: PickOne
+*OrderDependency: 10 AnySetup *PageSize
+*DefaultPageSize: Letter
+*PageSize Letter/US Letter:	"<</PageSize[612 792]/ImagingBBox null>>setpagedevice"
+*PageSize Legal/US Legal:	"<</PageSize[612 1008]/ImagingBBox null>>setpagedevice"
+*PageSize Executive/US Executive: "<</PageSize[522 756]/ImagingBBox null>>setpagedevice"
+*PageSize Tabloid/US Tabloid:	"<</PageSize[792 1224]/ImagingBBox null>>setpagedevice"
+*PageSize A3/A3:		"<</PageSize[842 1191]/ImagingBBox null>>setpagedevice"
+*PageSize A4/A4:		"<</PageSize[595 842]/ImagingBBox null>>setpagedevice"
+*PageSize A5/A5:		"<</PageSize[421 595]/ImagingBBox null>>setpagedevice"
+*PageSize B5/B5 (JIS):		"<</PageSize[516 729]/ImagingBBox null>>setpagedevice"
+*PageSize EnvISOB5/Envelope B5: "<</PageSize[499 709]/ImagingBBox null>>setpagedevice"
+*PageSize Env10/Envelope #10:	"<</PageSize[297 684]/ImagingBBox null>>setpagedevice"
+*PageSize EnvC5/Envelope C5:	"<</PageSize[459 649]/ImagingBBox null>>setpagedevice"
+*PageSize EnvDL/Envelope DL:	"<</PageSize[312 624]/ImagingBBox null>>setpagedevice"
+*PageSize EnvMonarch/Envelope Monarch: "<</PageSize[279 540]/ImagingBBox null>>setpagedevice"
+*CloseUI: *PageSize
+
+*OpenUI *PageRegion: PickOne
+*OrderDependency: 10 AnySetup *PageRegion
+*DefaultPageRegion: Letter
+*PageRegion Letter/US Letter:	"<</PageSize[612 792]/ImagingBBox null>>setpagedevice"
+*PageRegion Legal/US Legal:	"<</PageSize[612 1008]/ImagingBBox null>>setpagedevice"
+*PageRegion Executive/US Executive: "<</PageSize[522 756]/ImagingBBox null>>setpagedevice"
+*PageRegion Tabloid/US Tabloid:	"<</PageSize[792 1224]/ImagingBBox null>>setpagedevice"
+*PageRegion A3/A3:		"<</PageSize[842 1191]/ImagingBBox null>>setpagedevice"
+*PageRegion A4/A4:		"<</PageSize[595 842]/ImagingBBox null>>setpagedevice"
+*PageRegion A5/A5:		"<</PageSize[421 595]/ImagingBBox null>>setpagedevice"
+*PageRegion B5/B5 (JIS):	"<</PageSize[516 729]/ImagingBBox null>>setpagedevice"
+*PageRegion EnvISOB5/Envelope B5: "<</PageSize[499 709]/ImagingBBox null>>setpagedevice"
+*PageRegion Env10/Envelope #10:	"<</PageSize[297 684]/ImagingBBox null>>setpagedevice"
+*PageRegion EnvC5/Envelope C5:	"<</PageSize[459 649]/ImagingBBox null>>setpagedevice"
+*PageRegion EnvDL/Envelope DL:	"<</PageSize[312 624]/ImagingBBox null>>setpagedevice"
+*PageRegion EnvMonarch/Envelope Monarch: "<</PageSize[279 540]/ImagingBBox null>>setpagedevice"
+*CloseUI: *PageRegion
+
+*DefaultImageableArea: Letter 
+*ImageableArea Letter/US Letter:	"12 12 600 780"
+*ImageableArea Legal/US Legal:		"12 12 600 996"
+*ImageableArea Executive/US Executive:	"12 12 510 708"
+*ImageableArea Tabloid/US Tabloid:	"12 12 780 1212"
+*ImageableArea A3/A3:			"12 12 830 1179"
+*ImageableArea A4/A4:			"12 12 583 830"
+*ImageableArea A5/A5:			"12 12 409 583"
+*ImageableArea B5/JIS B5:		"12 12 504 717"
+*ImageableArea EnvISOB5/B5 (ISO):	"12 12 469 697"
+*ImageableArea Env10/Com-10:		"12 12 285 672"
+*ImageableArea EnvC5/EnvC5:		"12 12 447 637"
+*ImageableArea EnvDL/EnvDL:		"12 12 300 612"
+*ImageableArea EnvMonarch/Envelope Monarch: "12 12 267 528"
+
+*DefaultPaperDimension: Letter
+*PaperDimension Letter/US Letter:	"612 792"
+*PaperDimension Legal/US Legal:		"612 1008"
+*PaperDimension Executive/US Executive:	"522 756"
+*PaperDimension Tabloid/US Tabloid:	"792 1224"
+*PaperDimension A3/A3:			"842 1191"
+*PaperDimension A4/A4:			"595 842"
+*PaperDimension A5/A5:			"421 595"
+*PaperDimension B5/B5 (JIS):		"516 729"
+*PaperDimension EnvISOB5/Envelope B5:	"499 709"
+*PaperDimension Env10/Envelope #10:	"297 684"
+*PaperDimension EnvC5/Envelope C5:	"459 649"
+*PaperDimension EnvDL/Envelope DL:	"312 624"
+*PaperDimension EnvMonarch/Envelope Monarch: "279 540"
+
+*OpenUI *InputSlot/Media Source: PickOne
+*OrderDependency: 10 AnySetup *InputSlot
+*DefaultInputSlot: Default
+*InputSlot Default/Default: "<</MediaPosition 0>>setpagedevice"
+*InputSlot Auto/Automatically Select: "<</MediaPosition 1>>setpagedevice"
+*InputSlot MultiPurpose/Tray 1: "<</MediaPosition 3>>setpagedevice"
+*InputSlot Upper/Tray 2: "<</MediaPosition 4>>setpagedevice"
+*InputSlot Lower/Tray 3: "<</MediaPosition 5>>setpagedevice"
+*InputSlot LargeCapacity/Tray 4: "<</MediaPosition 7>>setpagedevice"
+*InputSlot Manual/Manual Feed: "<</MediaPosition 2>>setpagedevice"
+*InputSlot Envelope/Envelope Feed: "<</MediaPosition 6>>setpagedevice"
+*CloseUI: *InputSlot
+
+*OpenUI *Resolution/Output Resolution: PickOne
+*OrderDependency: 20 AnySetup *Resolution
+*DefaultResolution: 600dpi
+*Resolution 150dpi/150 DPI: "<</HWResolution[150 150]>>setpagedevice"
+*Resolution 300dpi/300 DPI: "<</HWResolution[300 300]>>setpagedevice"
+*Resolution 600dpi/600 DPI: "<</HWResolution[600 600]>>setpagedevice"
+*Resolution 1200dpi/1200 DPI: "<</HWResolution[1200 1200]>>setpagedevice"
+*CloseUI: *Resolution
+
+*OpenUI *Duplex/Double-Sided Printing: PickOne
+*OrderDependency: 20 AnySetup *Duplex
+*DefaultDuplex: None
+*Duplex None/Off:	"<</Duplex false>>setpagedevice"
+*Duplex DuplexNoTumble/Long Edge (Standard):	"<</Duplex true/Tumble false>>setpagedevice"
+*Duplex DuplexTumble/Short Edge (Flip):	"<</Duplex true/Tumble true>>setpagedevice"
+*CloseUI:	*Duplex
+
+*OpenGroup: InstallableOptions
+*OpenUI *OptionDuplex/Duplexer: Boolean
+*DefaultOptionDuplex: False
+*OptionDuplex True/Installed:	""
+*OptionDuplex False/Not Installed:	""
+*CloseUI: *OptionDuplex
+*CloseGroup: InstallableOptions
+
+*DefaultFont: Courier
+*Font AvantGarde-Book: Standard "(001.006S)" Standard ROM
+*Font AvantGarde-BookOblique: Standard "(001.006S)" Standard ROM
+*Font AvantGarde-Demi: Standard "(001.007S)" Standard ROM
+*Font AvantGarde-DemiOblique: Standard "(001.007S)" Standard ROM
+*Font Bookman-Demi: Standard "(001.004S)" Standard ROM
+*Font Bookman-DemiItalic: Standard "(001.004S)" Standard ROM
+*Font Bookman-Light: Standard "(001.004S)" Standard ROM
+*Font Bookman-LightItalic: Standard "(001.004S)" Standard ROM
+*Font Courier: Standard "(002.004S)" Standard ROM
+*Font Courier-Bold: Standard "(002.004S)" Standard ROM
+*Font Courier-BoldOblique: Standard "(002.004S)" Standard ROM
+*Font Courier-Oblique: Standard "(002.004S)" Standard ROM
+*Font Helvetica: Standard "(001.006S)" Standard ROM
+*Font Helvetica-Bold: Standard "(001.007S)" Standard ROM
+*Font Helvetica-BoldOblique: Standard "(001.007S)" Standard ROM
+*Font Helvetica-Narrow: Standard "(001.006S)" Standard ROM
+*Font Helvetica-Narrow-Bold: Standard "(001.007S)" Standard ROM
+*Font Helvetica-Narrow-BoldOblique: Standard "(001.007S)" Standard ROM
+*Font Helvetica-Narrow-Oblique: Standard "(001.006S)" Standard ROM
+*Font Helvetica-Oblique: Standard "(001.006S)" Standard ROM
+*Font NewCenturySchlbk-Bold: Standard "(001.009S)" Standard ROM
+*Font NewCenturySchlbk-BoldItalic: Standard "(001.007S)" Standard ROM
+*Font NewCenturySchlbk-Italic: Standard "(001.006S)" Standard ROM
+*Font NewCenturySchlbk-Roman: Standard "(001.007S)" Standard ROM
+*Font Palatino-Bold: Standard "(001.005S)" Standard ROM
+*Font Palatino-BoldItalic: Standard "(001.005S)" Standard ROM
+*Font Palatino-Italic: Standard "(001.005S)" Standard ROM
+*Font Palatino-Roman: Standard "(001.005S)" Standard ROM
+*Font Symbol: Special "(001.007S)" Special ROM
+*Font Times-Bold: Standard "(001.007S)" Standard ROM
+*Font Times-BoldItalic: Standard "(001.009S)" Standard ROM
+*Font Times-Italic: Standard "(001.007S)" Standard ROM
+*Font Times-Roman: Standard "(001.007S)" Standard ROM
+*Font ZapfChancery-MediumItalic: Standard "(001.007S)" Standard ROM
+*Font ZapfDingbats: Special "(001.004S)" Standard ROM
+*%
+*%
