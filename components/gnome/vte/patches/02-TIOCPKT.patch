This patch completely reworks and replaces the one from the solaris
userland gate.

Adds packet mode support for solaris.  Suitable for upstream vte.


--- vte-0.62.1.dist/meson.build	2020-11-30 14:05:34.350293090 +0000
+++ vte-0.62.1/meson.build	2020-11-29 12:31:37.000000000 +0000
@@ -151,6 +151,7 @@
   'stropts.h',
   'sys/resource.h',
   'sys/select.h',
+  'sys/stream.h',
   'sys/syslimits.h',
   'sys/termios.h',
   'sys/types.h',
--- vte-0.58.3/src/pty.cc.~1~	2020-12-02 19:25:04.426800220 +0000
+++ vte-0.58.3/src/pty.cc	2020-12-02 19:26:33.055612680 +0000
@@ -613,10 +613,18 @@
 static int
 fd_set_cpkt(int fd)
 {
+        int ret = 0;
+#if defined(TIOCPKT)
         /* tty_ioctl(4) -> every read() gives an extra byte at the beginning
          * notifying us of stop/start (^S/^Q) events. */
         int one = 1;
-        return ioctl(fd, TIOCPKT, &one);
+        ret = ioctl(fd, TIOCPKT, &one);
+#elif defined(__sun) && defined(HAVE_STROPTS_H)
+        if (isastream(fd) == 1 &&
+            ioctl(fd, I_FIND, "pckt") == 0)
+                ret = ioctl(fd, I_PUSH, "pckt");
+#endif
+        return ret;
 }
 
 static int
@@ -639,7 +647,7 @@
         if (fd_set_cpkt(fd) < 0) {
                 vte::util::restore_errno errsv;
                 _vte_debug_print(VTE_DEBUG_PTY,
-                                 "%s failed: %s", "ioctl(TIOCPKT)", g_strerror(errsv));
+                                 "%s failed: %s", "Setting packet mode", g_strerror(errsv));
                 return -1;
         }
 
@@ -702,7 +710,7 @@
         if (fd_set_cpkt(fd) < 0) {
                 vte::util::restore_errno errsv;
                 _vte_debug_print(VTE_DEBUG_PTY,
-                                 "%s failed: %s", "ioctl(TIOCPKT)", g_strerror(errsv));
+                                 "%s failed: %s", "Setting packet mode", g_strerror(errsv));
                 return -1;
         }
 
--- vte-0.62.1/src/vte.cc.~1~	2020-10-08 13:30:11.000000000 +0000
+++ vte-0.62.1/src/vte.cc	2020-11-30 19:33:27.690224374 +0000
@@ -29,6 +29,12 @@
 #ifdef HAVE_SYS_TERMIOS_H
 #include <sys/termios.h>
 #endif
+#ifdef HAVE_STROPTS_H
+#include <stropts.h>
+#endif
+#ifdef HAVE_SYS_STREAM_H
+#include <sys/stream.h>
+#endif
 
 #include <glib.h>
 #include <glib-unix.h>
@@ -3959,6 +3965,7 @@
 			bp = chunk->data + chunk->len;
 			len = 0;
 			do {
+#if defined(TIOCPKT)
                                 /* We'd like to read (fd, bp, rem); but due to TIOCPKT mode
                                  * there's an extra input byte returned at the beginning.
                                  * We need to see what that byte is, but otherwise drop it
@@ -4007,6 +4014,66 @@
                                                 }
 						break;
 				}
+#elif defined(__sun) && defined(HAVE_STROPTS_H)
+				static unsigned char ctl_s[128];
+				struct strbuf ctlbuf, databuf;
+				int ret, flags = 0;
+				bool have_data = false;
+
+				ctlbuf.buf = (caddr_t)ctl_s;
+				ctlbuf.maxlen = sizeof(ctl_s);
+				databuf.buf = (caddr_t)bp;
+				databuf.maxlen = rem;
+
+				ret = getmsg(fd, &ctlbuf, &databuf, &flags);
+				if (ret == -1) {
+					err = errno;
+					goto out;
+				} else if (ctlbuf.len == 1) {
+					switch (ctl_s[0]) {
+					case M_IOCTL:
+						pty_termios_changed();
+						break;
+					case M_STOP:
+						pty_scroll_lock_changed(true);
+						break;
+					case M_START:
+						pty_scroll_lock_changed(false);
+						break;
+					case M_DATA:
+						have_data = true;
+						break;
+					}
+				} else if (ctlbuf.len == -1 && databuf.len != -1) {
+					// MOREDATA
+					have_data = true;
+				}
+
+				if (have_data) {
+					if (databuf.len == 0) {
+						eof = true;
+						goto out;
+					}
+					bp += databuf.len;
+					rem -= databuf.len;
+					len += databuf.len;
+				}
+#else /* no TIOCPKT && no STREAMS pty */
+				int ret = read(fd, bp, rem);
+				switch (ret) {
+					case -1:
+						err = errno;
+						goto out;
+					case 0:
+						eof = true;
+						goto out;
+					default:
+						bp += ret;
+						rem -= ret;
+						len += ret;
+						break;
+				}
+#endif
 			} while (rem);
 out:
 			chunk->len += len;
