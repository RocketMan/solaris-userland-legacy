Oracle Bug 15172798 - SUNBT4907034 XtOverrideTranslations() takes 10x more
  cycles than 32-bit.

This fix is SPARC-specific and should be reworked to apply to both big- &
little-endian machines before being sent upstream.

Root cause:
64bit libXt has worse performance compared with 32bit libXt because current
libXt construct the converter hash table by using the second byte of address
member of from data structure. However, in 64bit model, most second byte are
0, which lower the hash table effeciency.

Solution:
If current application is 64bit model, use the 7th byte to hash the
converter. Moreover, add more optimization macro definition.

--- libXt-1.1.5/src/Convert.c
+++ libXt-1.1.5/src/Convert.c
@@ -707,7 +707,12 @@ register Cardinal   i;
     LOCK_PROCESS;
     /* Try to find cache entry for conversion */
     hash = ((long) converter >> 2) + from->size + *((char *) from->addr);
-    if (from->size > 1) hash += ((char *) from->addr)[1];
+    if (from->size > 1) {
+	if (sizeof(long) == 4)
+            hash += ((char *) from->addr)[1];
+        else
+            hash += ((char *) from->addr)[6];
+    }
 
     for (p = cacheHashTable[hash & CACHEHASHMASK]; p; p = p->next) {
 	if ((p->hash == hash)
@@ -805,7 +810,12 @@ }
     LOCK_PROCESS;
     /* Try to find cache entry for conversion */
     hash = ((long)(converter) >> 2) + from->size + *((char *) from->addr);
-    if (from->size > 1) hash += ((char *) from->addr)[1];
+    if (from->size > 1) {
+	if (sizeof(long) == 4)
+	    hash += ((char *) from->addr)[1];
+	else
+	    hash += ((char *) from->addr)[6];
+    }
 
     if (cP->cache_type != XtCacheNone) {
 	for (p = cacheHashTable[hash & CACHEHASHMASK]; p; p = p->next){
