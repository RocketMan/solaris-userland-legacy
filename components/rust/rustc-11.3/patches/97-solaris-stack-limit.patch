--- a/vendor/stacker/src/lib.rs	2020-08-14 14:49:47.142682493 +0000
+++ b/vendor/stacker/src/lib.rs	2020-08-14 14:58:30.363074986 +0000
@@ -355,7 +355,7 @@
             );
             Some(mi.assume_init().AllocationBase as usize + get_thread_stack_guarantee() + 0x1000)
         }
-    } else if #[cfg(any(target_os = "linux", target_os="solaris", target_os = "netbsd"))] {
+    } else if #[cfg(any(target_os = "linux", target_os = "netbsd"))] {
         unsafe fn guess_os_stack_limit() -> Option<usize> {
             let mut attr = std::mem::MaybeUninit::<libc::pthread_attr_t>::uninit();
             assert_eq!(libc::pthread_attr_init(attr.as_mut_ptr()), 0);
@@ -393,6 +393,12 @@
             Some(libc::pthread_get_stackaddr_np(libc::pthread_self()) as usize -
                 libc::pthread_get_stacksize_np(libc::pthread_self()) as usize)
         }
+    } else if #[cfg(target_os = "solaris")] {
+        unsafe fn guess_os_stack_limit() -> Option<usize> {
+            let mut current_stack: libc::stack_t = std::mem::zeroed();
+            assert_eq!(libc::stack_getbounds(&mut current_stack), 0);
+            Some(current_stack.ss_sp as usize)
+        }
     } else {
         // fallback for other platforms is to always increase the stack if we're on
         // the root stack. After we increased the stack once, we know the new stack
--- a/vendor/stacker/.cargo-checksum.json	2020-07-13 19:18:17.000000000 +0000
+++ b/vendor/stacker/.cargo-checksum.json	2020-08-14 16:08:07.566554475 +0000
@@ -1,1 +1,1 @@
-{"files":{"Cargo.toml":"8c0c5d0acfd8dd1f0b61404df9f5b342fc6c1f3744f877af7a522811bf0ae918","Cross.toml":"b5f300c31f4522caba733582f4957f693a4017f4728a69805390b63ad69eff67","LICENSE-APACHE":"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2","LICENSE-MIT":"378f5840b258e2779c39418f3f2d7b2ba96f1c7917dd6be0713f88305dbda397","README.md":"e938c263b76ff66671013f0f77755aa289e807d91b7d39471ba92dea6782929e","build.rs":"856a26a0d6b2eabe2e36f66a267d172c027794f03cb57d6cad37073e1e1ce6c5","src/arch/asm.h":"4c4db945e854e4ce3f0b7ba8da3755613c0e4513a7aab0604bd6a67c0ff2192d","src/arch/windows.c":"e98e08f6b5102480b8fa4dfa7ee13441845202f5ba81c60b13da2800e0a8630c","src/lib.rs":"0f3602e048ab4bc5304226b9c171aee46bd58d0e354ead9c7d2ba6ac6d6f262f","tests/simple.rs":"8046c2ceb3cfd506803e505621366354a3e8b65e44d07a573af76e8eb156131f","tests/smoke.rs":"9bbb5d9f1863b2e80ec639394ddaf04a7ff297ded1ca3c121b419bb7f54dce7d"},"package":"72dd941b456e1c006d6b9f27c526d5b69281288aeea8cba82c19d3843d8ccdd2"}
\ No newline at end of file
+{"files":{"Cargo.toml":"8c0c5d0acfd8dd1f0b61404df9f5b342fc6c1f3744f877af7a522811bf0ae918","Cross.toml":"b5f300c31f4522caba733582f4957f693a4017f4728a69805390b63ad69eff67","LICENSE-APACHE":"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2","LICENSE-MIT":"378f5840b258e2779c39418f3f2d7b2ba96f1c7917dd6be0713f88305dbda397","README.md":"e938c263b76ff66671013f0f77755aa289e807d91b7d39471ba92dea6782929e","build.rs":"856a26a0d6b2eabe2e36f66a267d172c027794f03cb57d6cad37073e1e1ce6c5","src/arch/asm.h":"4c4db945e854e4ce3f0b7ba8da3755613c0e4513a7aab0604bd6a67c0ff2192d","src/arch/windows.c":"e98e08f6b5102480b8fa4dfa7ee13441845202f5ba81c60b13da2800e0a8630c","src/lib.rs":"5d587fe44a971620bf994f778db4bfaf5d18bb25350cae489c680765ba65d02b","tests/simple.rs":"8046c2ceb3cfd506803e505621366354a3e8b65e44d07a573af76e8eb156131f","tests/smoke.rs":"9bbb5d9f1863b2e80ec639394ddaf04a7ff297ded1ca3c121b419bb7f54dce7d"},"package":"72dd941b456e1c006d6b9f27c526d5b69281288aeea8cba82c19d3843d8ccdd2"}
