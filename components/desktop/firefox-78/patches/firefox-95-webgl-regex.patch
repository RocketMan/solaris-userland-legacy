--- a/dom/canvas/WebGLValidateStrings.cpp	2020-07-08 17:08:25.036799221 +0000
+++ b/dom/canvas/WebGLValidateStrings.cpp	2020-07-08 18:06:26.827283014 +0000
@@ -26,61 +26,71 @@
 */
 
 std::string CommentsToSpaces(const std::string& src) {
-  constexpr auto flags =
-      std::regex::ECMAScript | std::regex::nosubs | std::regex::optimize;
-
-  static const auto RE_COMMENT_BEGIN = std::regex("/[*/]", flags);
-  static const auto RE_LINE_COMMENT_END = std::regex(R"([^\\]\n)", flags);
-  static const auto RE_BLOCK_COMMENT_END = std::regex(R"(\*/)", flags);
-
   std::string ret;
   ret.reserve(src.size());
 
-  // Replace all comments with block comments with the right number of newlines.
-  // Line positions may be off, but line numbers will be accurate, which is more
-  // important.
-
-  auto itr = src.begin();
-  const auto end = src.end();
-  std::smatch match;
-  while (std::regex_search(itr, end, match, RE_COMMENT_BEGIN)) {
-    MOZ_ASSERT(match.length() == 2);
-    const auto commentBegin = itr + match.position();
-    ret.append(itr, commentBegin);
-
-    itr = commentBegin + match.length();
-
-    const bool isBlockComment = (*(commentBegin + 1) == '*');
-    const auto* endRegex = &RE_LINE_COMMENT_END;
-    if (isBlockComment) {
-      endRegex = &RE_BLOCK_COMMENT_END;
-    }
-
-    if (isBlockComment) {
-      ret += "/*";
-    }
+  auto srcItr = src.begin();
+  const auto srcEnd = src.end();
 
-    auto commentEnd = end;
-    if (!isBlockComment && itr != end && *itr == '\n') {
-      commentEnd = itr + 1;  // '//\n'
-    } else if (std::regex_search(itr, end, match, *endRegex)) {
-      commentEnd = itr + match.position() + match.length();
-    } else {
-      return ret;
+  const auto fnEmitUntil = [&](const decltype(srcItr)& nextSrcItr) {
+    while (srcItr != nextSrcItr) {
+       ret.append(srcItr, srcItr+1);
+       ++srcItr;
     }
+  };
 
-    for (; itr != commentEnd; ++itr) {
-      const auto cur = *itr;
-      if (cur == '\n') {
-        ret += cur;
+  const auto fnFindSoonestOf = [&](const char* needles[],
+                                   size_t needleCount,
+                                   size_t* const out_foundId) {
+    auto foundItr = srcItr;
+    while (foundItr != srcEnd) {
+      const auto haystack = std::string(foundItr, srcEnd);
+      for (size_t i = 0; i < needleCount; i++) {
+        if (haystack.compare(0, strlen(needles[i]), needles[i]) == 0) {
+          *out_foundId = i;
+          return foundItr;
+        }
       }
+      ++foundItr;
     }
-    if (isBlockComment) {
-      ret += "*/";
+    *out_foundId = needleCount;
+    return foundItr;
+  };
+                           
+  const char* commentBeginnings[] = { "//", "/*", "" };
+  const char* lineCommentEndings[] = { "\\\n", "\n", "" };
+  const char* blockCommentEndings[] = { "\n", "*/", "" };
+
+  while (srcItr != srcEnd) {
+    size_t foundId;
+    fnEmitUntil(fnFindSoonestOf(commentBeginnings, 2, &foundId));
+    fnEmitUntil(srcItr +
+                strlen(commentBeginnings[foundId]));
+    switch (foundId) {
+    case 0:  // line comment
+      while (true) {
+        size_t endId;
+        srcItr = fnFindSoonestOf(lineCommentEndings, 2, &endId);
+        fnEmitUntil(srcItr + strlen(lineCommentEndings[endId]));
+        if (endId == 0) continue;
+        break;
+      }
+      break;
+    case 1:  // block comment
+      while (true) {
+        size_t endId;
+        srcItr = fnFindSoonestOf(blockCommentEndings, 2, &endId);
+        fnEmitUntil(srcItr + strlen(blockCommentEndings[endId]));
+        if (endId == 0) continue;
+        break;
+      }
+      break;
+
+    default:  // not found
+      break;
     }
   }
-
-  ret.append(itr, end);
+  
   return ret;
 }
 
--- a/dom/canvas/WebGLContext.cpp	2020-07-08 21:22:45.051238877 +0000
+++ b/dom/canvas/WebGLContext.cpp	2020-07-09 00:50:12.666445943 +0000
@@ -1945,31 +1945,47 @@
 // ---------------------------------
 
 Maybe<webgl::IndexedName> webgl::ParseIndexed(const std::string& str) {
-  static const std::regex kRegex("(.*)\\[([0-9]+)\\]");
-
-  std::smatch match;
-  if (!std::regex_match(str, match, kRegex)) return {};
-
-  const auto index = std::stoull(match[2]);
-  return Some(webgl::IndexedName{match[1], index});
+  size_t pos = str.find("[");
+  if(pos == std::string::npos) return {};
+  const auto index = std::stoull(str.substr(pos+1));
+  return Some(webgl::IndexedName{str.substr(0, pos), index});
 }
 
 // ExplodeName("foo.bar[3].x") -> ["foo", ".", "bar", "[", "3", "]", ".", "x"]
-static std::vector<std::string> ExplodeName(const std::string& str) {
+static std::vector<std::string> ExplodeName(const std::string& src) {
   std::vector<std::string> ret;
 
-  static const std::regex kSep("[.[\\]]");
+  auto srcItr = src.begin();
+  const auto srcEnd = src.end();
 
-  auto itr = std::regex_token_iterator<decltype(str.begin())>(
-      str.begin(), str.end(), kSep, {-1, 0});
-  const auto end = decltype(itr)();
-
-  for (; itr != end; ++itr) {
-    const auto& part = itr->str();
-    if (part.size()) {
-      ret.push_back(part);
+  const auto fnFindSoonestOf = [&](const char* needles[],
+                                   size_t needleCount) {
+    auto foundItr = srcItr;
+    while (foundItr != srcEnd) {
+      const auto haystack = std::string(foundItr, srcEnd);
+      for (size_t i = 0; i < needleCount; i++) {
+        if (haystack.compare(0, strlen(needles[i]), needles[i]) == 0) {
+          return foundItr;
+        }
+      }
+      ++foundItr;
     }
+    return foundItr;
+  };
+                           
+  const char* separators[] = { ".", "[", "]" };
+  
+  while (srcItr != srcEnd) {
+    auto sep = fnFindSoonestOf(separators, 3);
+    if(srcItr != sep)
+      ret.push_back(std::string(srcItr, sep));
+    if(sep != srcEnd) {
+      ret.push_back(std::string(sep, sep+1));
+      sep++;
+    }
+    srcItr = sep;
   }
+
   return ret;
 }
 
