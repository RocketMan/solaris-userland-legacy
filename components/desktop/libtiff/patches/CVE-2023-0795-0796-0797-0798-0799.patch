Patch taken from 
https://gitlab.com/libtiff/libtiff/-/commit/afaabc3e50d4e5d80a94143f7e3c997e7e410f68
and modified to apply with the current version 4.4.0.

From 69818e2f2d246e6631ac2a2da692c3706b849c38 Mon Sep 17 00:00:00 2001
From: Su_Laus <sulau@freenet.de>
Date: Sun, 29 Jan 2023 11:09:26 +0100
Subject: [PATCH] tiffcrop: Amend rotateImage() not to toggle the input (main)
 image width and length parameters when only cropped image sections are
 rotated. Remove buffptr from region structure because never used.

Closes #492 #493 #494 #495 #499 #518 #519

--- tiff-4.4.0/tools/tiffcrop.c.orig	2023-02-20 22:55:29.209953009 -0800
+++ tiff-4.4.0/tools/tiffcrop.c	2023-02-20 23:38:59.452240919 -0800
@@ -265,7 +265,6 @@
   uint32_t width;     /* width in pixels */
   uint32_t length;    /* length in pixels */
   uint32_t buffsize;  /* size of buffer needed to hold the cropped region */
-  unsigned char *buffptr; /* address of start of the region */
 };
 
 /* Cropping parameters from command line and image data 
@@ -520,7 +519,7 @@
 static int rotateContigSamples32bits(uint16_t, uint16_t, uint16_t, uint32_t,
                                      uint32_t, uint32_t, uint8_t *, uint8_t *);
 static int rotateImage(uint16_t, struct image_data *, uint32_t *, uint32_t *,
-                       unsigned char **);
+                       unsigned char **, int);
 static int mirrorImage(uint16_t, uint16_t, uint16_t, uint32_t, uint32_t,
                        unsigned char *);
 static int invertImage(uint16_t, uint16_t, uint16_t, uint32_t, uint32_t,
@@ -5189,7 +5188,6 @@
      cps->regionlist[i].width = 0;
      cps->regionlist[i].length = 0;
      cps->regionlist[i].buffsize = 0;
-     cps->regionlist[i].buffptr = NULL;
      cps->zonelist[i].position = 0;
      cps->zonelist[i].total = 0;
      }
@@ -6486,7 +6484,9 @@
       return (-1);
       }
  
-    if (rotateImage(rotation, image, &image->width, &image->length, work_buff_ptr))
+    uint32_t width = image->width;
+    uint32_t length = image->length;
+    if (rotateImage(rotation, image, &width, &length, work_buff_ptr, TRUE))
       {
       TIFFError ("correct_orientation", "Unable to rotate image");
       return (-1);
@@ -6554,7 +6554,6 @@
     /* These should not be needed for composite images */
     crop->regionlist[i].width = crop_width;
     crop->regionlist[i].length = crop_length;
-    crop->regionlist[i].buffptr = crop_buff;
 
     src_rowsize = ((img_width * bps * spp) + 7) / 8;
     dst_rowsize = (((crop_width * bps * count) + 7) / 8);
@@ -6791,7 +6790,6 @@
 
   crop->regionlist[region].width = crop_width;
   crop->regionlist[region].length = crop_length;
-  crop->regionlist[region].buffptr = crop_buff;
 
   src = read_buff;
   dst = crop_buff;
@@ -7669,7 +7667,7 @@
     if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */
       {
       if (rotateImage(crop->rotation, image, &crop->combined_width, 
-                      &crop->combined_length, &crop_buff))
+                      &crop->combined_length, &crop_buff, FALSE))
         {
         TIFFError("processCropSelections", 
                   "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);
@@ -7779,7 +7777,7 @@
            * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!
            */
 	if (rotateImage(crop->rotation, image, &crop->regionlist[i].width, 
-			&crop->regionlist[i].length, &crop_buff))
+			&crop->regionlist[i].length, &crop_buff, FALSE))
           {
           TIFFError("processCropSelections", 
                     "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);
@@ -7911,7 +7909,7 @@
   if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */
     {
     if (rotateImage(crop->rotation, image, &crop->combined_width, 
-                    &crop->combined_length, crop_buff_ptr))
+                    &crop->combined_length, crop_buff_ptr, TRUE))
       {
       TIFFError("createCroppedImage", 
                 "Failed to rotate image or cropped selection by %"PRIu16" degrees", crop->rotation);
@@ -8574,7 +8572,8 @@
 /* Rotate an image by a multiple of 90 degrees clockwise */
 static int
 rotateImage(uint16_t rotation, struct image_data *image, uint32_t *img_width,
-            uint32_t *img_length, unsigned char **ibuff_ptr)
+            uint32_t *img_length, unsigned char **ibuff_ptr,
+            int rot_image_params)
   {
   int      shift_width;
   uint32_t   bytes_per_pixel, bytes_per_sample;
@@ -8764,11 +8763,15 @@
 
               *img_width = length;
               *img_length = width;
-              image->width = length;
-              image->length = width;
-              res_temp = image->xres;
-              image->xres = image->yres;
-              image->yres = res_temp;
+              /* Only toggle image parameters if whole input image is rotated. */
+              if (rot_image_params)
+              {
+                  image->width = length;
+                  image->length = width;
+                  res_temp = image->xres;
+                  image->xres = image->yres;
+                  image->yres = res_temp;
+              }
 	      break;
 
     case 270: if ((bps % 8) == 0) /* byte aligned data */
@@ -8841,11 +8844,15 @@
 
               *img_width = length;
               *img_length = width;
-              image->width = length;
-              image->length = width;
-              res_temp = image->xres;
-              image->xres = image->yres;
-              image->yres = res_temp;
+              /* Only toggle image parameters if whole input image is rotated. */
+              if (rot_image_params)
+              {
+                  image->width = length;
+                  image->length = width;
+                  res_temp = image->xres;
+                  image->xres = image->yres;
+                  image->yres = res_temp;
+              }
               break;
     default:
               break;
