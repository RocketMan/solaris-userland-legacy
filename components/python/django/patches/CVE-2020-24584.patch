Fixes CVE-2020-24584.
Desc:
  A flaw was found in django. The intermediate-level directories of the file
  system cache had the systems standard umask rather than `0o077` (no group or
  others permissions). The highest threat from this vulnerability is to data
  confidentiality.

Backported from Django master:
https://github.com/django/django/commit/1853724acaf17ed7414d54c7d2b5563a25025a71

--- Django-1.11.29/django/core/cache/backends/filebased.py
+++ Django-1.11.29/django/core/cache/backends/filebased.py
@@ -102,6 +102,9 @@ class FileBasedCache(BaseCache):
 
     def _createdir(self):
         if not os.path.exists(self._dir):
+            # Set the umask because os.makedirs() doesn't apply the "mode" argument
+            # to intermediate-level directories.
+            old_umask = os.umask(0o077)
             try:
                 os.makedirs(self._dir, 0o700)
             except OSError as e:
@@ -109,6 +112,8 @@ class FileBasedCache(BaseCache):
                     raise EnvironmentError(
                         "Cache directory '%s' does not exist "
                         "and could not be created'" % self._dir)
+            finally:
+                os.umask(old_umask)
 
     def _key_to_file(self, key, version=None):
         """
--- Django-1.11.29/tests/cache/tests.py
+++ Django-1.11.29/tests/cache/tests.py
@@ -9,6 +9,7 @@ import io
 import os
 import re
 import shutil
+import sys
 import tempfile
 import threading
 import time
@@ -1367,6 +1368,27 @@ class FileBasedCacheTests(BaseCacheTests
         # Returns the default instead of erroring.
         self.assertEqual(cache.get('foo', 'baz'), 'baz')
 
+    @unittest.skipIf(
+        sys.platform == 'win32',
+        'Windows only partially supports umasks and chmod.',
+    )
+    def test_cache_dir_permissions(self):
+        os.rmdir(self.dirname)
+        dir_path = os.path.join(self.dirname, 'nested', 'filebasedcache')
+        for cache_params in settings.CACHES.values():
+            cache_params['LOCATION'] = dir_path
+        setting_changed.send(self.__class__, setting='CACHES', enter=False)
+        cache.set('foo', 'bar')
+        self.assertIs(os.path.exists(dir_path), True)
+        tests = [
+            dir_path,
+            os.path.join(self.dirname, 'nested'),
+            self.dirname,
+        ]
+        for directory in tests:
+            dir_mode = os.stat(directory).st_mode & 0o777
+            self.assertEqual(dir_mode, 0o700)
+
     def test_get_does_not_ignore_non_enoent_errno_values(self):
         with mock.patch.object(io, 'open', side_effect=IOError):
             with self.assertRaises(IOError):
