Pillow 5.1.0 has a problem with unaligned access, which results in core dumps on SPARC.

This was backported from upstream and slightly modified to work correctly:
https://github.com/python-pillow/Pillow/commit/7a4af2b7671b14163f61c7f88889fad66e50d77b


--- Pillow-5.1.0/src/_imaging.c
+++ Pillow-5.1.0/src/_imaging.c
@@ -375,7 +375,8 @@ getlist(PyObject* arg, Py_ssize_t* lengt
     Py_ssize_t i, n;
     int itemp;
     double dtemp;
-    void* list;
+    FLOAT32 ftemp;
+    UINT8* list;
     PyObject* seq;
     PyObject* op;
 
@@ -410,19 +411,19 @@ getlist(PyObject* arg, Py_ssize_t* lengt
         switch (type) {
         case TYPE_UINT8:
             itemp = PyInt_AsLong(op);
-            ((UINT8*)list)[i] = CLIP(itemp);
+            list[i] = CLIP(itemp);
             break;
         case TYPE_INT32:
             itemp = PyInt_AsLong(op);
-            ((INT32*)list)[i] = itemp;
+            memcpy(list + i * sizeof(INT32), &itemp, sizeof(itemp));
             break;
         case TYPE_FLOAT32:
-            dtemp = PyFloat_AsDouble(op);
-            ((FLOAT32*)list)[i] = (FLOAT32) dtemp;
+            ftemp = (FLOAT32)PyFloat_AsDouble(op);
+            memcpy(list + i * sizeof(ftemp), &ftemp, sizeof(ftemp));
             break;
         case TYPE_DOUBLE:
             dtemp = PyFloat_AsDouble(op);
-            ((double*)list)[i] = (double) dtemp;
+            memcpy(list + i * sizeof(dtemp), &dtemp, sizeof(dtemp));
             break;
         }
     }
@@ -491,6 +492,8 @@ getink(PyObject* color, Imaging im, char
        to return it into a 32 bit C long
     */
     PY_LONG_LONG r = 0;
+    FLOAT32 ftmp;
+    INT32 itmp;
 
     /* fill ink buffer (four bytes) with something that can
        be cast to either UINT8 or INT32 */
@@ -556,14 +559,16 @@ getink(PyObject* color, Imaging im, char
         /* signed integer */
         if (rIsInt != 1)
             return NULL;
-        *(INT32*) ink = r;
+        itmp = r;
+        memcpy(ink, &itmp, sizeof(itmp));
         return ink;
     case IMAGING_TYPE_FLOAT32:
         /* floating point */
         f = PyFloat_AsDouble(color);
         if (f == -1.0 && PyErr_Occurred())
             return NULL;
-        *(FLOAT32*) ink = (FLOAT32) f;
+        ftmp = f;
+        memcpy(ink, &ftmp, sizeof(ftmp));
         return ink;
     case IMAGING_TYPE_SPECIAL:
         if (strncmp(im->mode, "I;16", 4) == 0) {
--- Pillow-5.1.0/src/libImaging/Access.c
+++ Pillow-5.1.0/src/libImaging/Access.c
@@ -94,11 +94,11 @@ static void
 get_pixel_16L(Imaging im, int x, int y, void* color)
 {
     UINT8* in = (UINT8*) &im->image[y][x+x];
-    UINT16* out = color;
 #ifdef WORDS_BIGENDIAN
-    out[0] = in[0] + (in[1]<<8);
+    UINT16 out = in[0] + (in[1]<<8);
+    memcpy(color, &out, sizeof(out));
 #else
-    out[0] = *(UINT16*) in;
+    memcpy(color, in, sizeof(UINT16));
 #endif
 }
 
@@ -106,11 +106,11 @@ static void
 get_pixel_16B(Imaging im, int x, int y, void* color)
 {
     UINT8* in = (UINT8*) &im->image[y][x+x];
-    UINT16* out = color;
 #ifdef WORDS_BIGENDIAN
-    out[0] = *(UINT16*) in;
+    memcpy(color, in, sizeof(UINT16));
 #else
-    out[0] = in[1] + (in[0]<<8);
+    UINT16 out = in[1] + (in[0]<<8);
+    memcpy(color, &out, sizeof(out));
 #endif
 }
 
@@ -125,11 +125,11 @@ static void
 get_pixel_32L(Imaging im, int x, int y, void* color)
 {
     UINT8* in = (UINT8*) &im->image[y][x*4];
-    INT32* out = color;
 #ifdef WORDS_BIGENDIAN
-    out[0] = in[0] + (in[1]<<8) + (in[2]<<16) + (in[3]<<24);
+    INT32 out = in[0] + (in[1]<<8) + (in[2]<<16) + (in[3]<<24);
+    memcpy(color, &out, sizeof(out));
 #else
-    out[0] = *(INT32*) in;
+    memcpy(color, in, sizeof(INT32));
 #endif
 }
 
@@ -137,11 +137,11 @@ static void
 get_pixel_32B(Imaging im, int x, int y, void* color)
 {
     UINT8* in = (UINT8*) &im->image[y][x*4];
-    INT32* out = color;
 #ifdef WORDS_BIGENDIAN
-    out[0] = *(INT32*) in;
+    memcpy(color, in, sizeof(INT32));
 #else
-    out[0] = in[3] + (in[2]<<8) + (in[1]<<16) + (in[0]<<24);
+    INT32 out = in[3] + (in[2]<<8) + (in[1]<<16) + (in[0]<<24);
+    memcpy(color, &out, sizeof(out));
 #endif
 }
 
--- Pillow-5.1.0/src/libImaging/Bands.c
+++ Pillow-5.1.0/src/libImaging/Bands.c
@@ -53,7 +53,8 @@ ImagingGetBand(Imaging imIn, int band)
         UINT8* out = imOut->image8[y];
         x = 0;
         for (; x < imIn->xsize - 3; x += 4) {
-            *((UINT32*) (out + x)) = MAKE_UINT32(in[0], in[4], in[8], in[12]);
+            UINT32 v = MAKE_UINT32(in[0], in[4], in[8], in[12]);
+            memcpy(out + x, &v, sizeof(v));
             in += 16;
         }
         for (; x < imIn->xsize; x++) {
@@ -101,8 +102,10 @@ ImagingSplit(Imaging imIn, Imaging bands
             UINT8* out1 = bands[1]->image8[y];
             x = 0;
             for (; x < imIn->xsize - 3; x += 4) {
-                *((UINT32*) (out0 + x)) = MAKE_UINT32(in[0], in[4], in[8], in[12]);
-                *((UINT32*) (out1 + x)) = MAKE_UINT32(in[0+3], in[4+3], in[8+3], in[12+3]);
+                UINT32 v = MAKE_UINT32(in[0], in[4], in[8], in[12]);
+                memcpy(out0 + x, &v, sizeof(v));
+                v = MAKE_UINT32(in[0+3], in[4+3], in[8+3], in[12+3]);
+                memcpy(out1 + x, &v, sizeof(v));
                 in += 16;
             }
             for (; x < imIn->xsize; x++) {
@@ -119,9 +122,12 @@ ImagingSplit(Imaging imIn, Imaging bands
             UINT8* out2 = bands[2]->image8[y];
             x = 0;
             for (; x < imIn->xsize - 3; x += 4) {
-                *((UINT32*) (out0 + x)) = MAKE_UINT32(in[0], in[4], in[8], in[12]);
-                *((UINT32*) (out1 + x)) = MAKE_UINT32(in[0+1], in[4+1], in[8+1], in[12+1]);
-                *((UINT32*) (out2 + x)) = MAKE_UINT32(in[0+2], in[4+2], in[8+2], in[12+2]);
+                UINT32 v = MAKE_UINT32(in[0], in[4], in[8], in[12]);
+                memcpy(out0 + x, &v, sizeof(v));
+                v = MAKE_UINT32(in[0+1], in[4+1], in[8+1], in[12+1]);
+                memcpy(out1 + x, &v, sizeof(v));
+                v = MAKE_UINT32(in[0+2], in[4+2], in[8+2], in[12+2]);
+                memcpy(out2 + x, &v, sizeof(v));
                 in += 16;
             }
             for (; x < imIn->xsize; x++) {
@@ -140,10 +146,14 @@ ImagingSplit(Imaging imIn, Imaging bands
             UINT8* out3 = bands[3]->image8[y];
             x = 0;
             for (; x < imIn->xsize - 3; x += 4) {
-                *((UINT32*) (out0 + x)) = MAKE_UINT32(in[0], in[4], in[8], in[12]);
-                *((UINT32*) (out1 + x)) = MAKE_UINT32(in[0+1], in[4+1], in[8+1], in[12+1]);
-                *((UINT32*) (out2 + x)) = MAKE_UINT32(in[0+2], in[4+2], in[8+2], in[12+2]);
-                *((UINT32*) (out3 + x)) = MAKE_UINT32(in[0+3], in[4+3], in[8+3], in[12+3]);
+                UINT32 v = MAKE_UINT32(in[0], in[4], in[8], in[12]);
+                memcpy(out0 + x, &v, sizeof(v));
+                v = MAKE_UINT32(in[0+1], in[4+1], in[8+1], in[12+1]);
+                memcpy(out1 + x, &v, sizeof(v));
+                v = MAKE_UINT32(in[0+2], in[4+2], in[8+2], in[12+2]);
+                memcpy(out2 + x, &v, sizeof(v));
+                v = MAKE_UINT32(in[0+3], in[4+3], in[8+3], in[12+3]);
+                memcpy(out3 + x, &v, sizeof(v));
                 in += 16;
             }
             for (; x < imIn->xsize; x++) {
--- Pillow-5.1.0/src/libImaging/Convert.c
+++ Pillow-5.1.0/src/libImaging/Convert.c
@@ -230,42 +230,46 @@ static void
 rgb2i(UINT8* out_, const UINT8* in, int xsize)
 {
     int x;
-    INT32* out = (INT32*) out_;
-    for (x = 0; x < xsize; x++, in += 4)
-        *out++ = L24(in) >> 16;
+    for (x = 0; x < xsize; x++, in += 4, out_ += 4) {
+        INT32 v = L24(in) >> 16;
+        memcpy(out_, &v, sizeof(v));
+    }
 }
 
 static void
 rgb2f(UINT8* out_, const UINT8* in, int xsize)
 {
     int x;
-    FLOAT32* out = (FLOAT32*) out_;
-    for (x = 0; x < xsize; x++, in += 4)
-        *out++ = (float) L(in) / 1000.0F;
+    for (x = 0; x < xsize; x++, in += 4, out_ += 4) {
+        FLOAT32 v = (float) L(in) / 1000.0F;
+        memcpy(out_, &v, sizeof(v));
+    }
 }
 
 static void
 rgb2bgr15(UINT8* out_, const UINT8* in, int xsize)
 {
     int x;
-    UINT16* out = (UINT16*) out_;
-    for (x = 0; x < xsize; x++, in += 4)
-        *out++ =
+    for (x = 0; x < xsize; x++, in += 4, out_ += 2) {
+        UINT16 v =
             ((((UINT16)in[0])<<7)&0x7c00) +
             ((((UINT16)in[1])<<2)&0x03e0) +
             ((((UINT16)in[2])>>3)&0x001f);
+        memcpy(out_, &v, sizeof(v));
+    }
 }
 
 static void
 rgb2bgr16(UINT8* out_, const UINT8* in, int xsize)
 {
     int x;
-    UINT16* out = (UINT16*) out_;
-    for (x = 0; x < xsize; x++, in += 4)
-        *out++ =
+    for (x = 0; x < xsize; x++, in += 4, out_ += 2) {
+        UINT16 v =
             ((((UINT16)in[0])<<8)&0xf800) +
             ((((UINT16)in[1])<<3)&0x07e0) +
             ((((UINT16)in[2])>>3)&0x001f);
+        memcpy(out_, &v, sizeof(v));
+    }
 }
 
 static void
@@ -491,12 +495,13 @@ rgbT2rgba(UINT8* out, int xsize, int r,
     UINT32 repl = trns & 0x00ffffff;
 #endif
 
-    UINT32* tmp = (UINT32 *)out;
     int i;
 
-    for (i=0; i < xsize; i++ ,tmp++) {
-        if (tmp[0]==trns) {
-            tmp[0]=repl;
+    for (i=0; i < xsize; i++ ,out += sizeof(trns)) {
+        UINT32 v;
+        memcpy(&v, out, sizeof(v));
+        if (v==trns) {
+            memcpy(out, &repl, sizeof(repl));
         }
     }
 }
@@ -554,32 +559,35 @@ static void
 bit2i(UINT8* out_, const UINT8* in, int xsize)
 {
     int x;
-    INT32* out = (INT32*) out_;
-    for (x = 0; x < xsize; x++)
-        *out++ = (*in++ != 0) ? 255 : 0;
+    for (x = 0; x < xsize; x++, out_ += 4) {
+        INT32 v = (*in++ != 0) ? 255 : 0;
+        memcpy(out_, &v, sizeof(v));
+    }
 }
 
 static void
 l2i(UINT8* out_, const UINT8* in, int xsize)
 {
     int x;
-    INT32* out = (INT32*) out_;
-    for (x = 0; x < xsize; x++)
-        *out++ = (INT32) *in++;
+    for (x = 0; x < xsize; x++, out_ += 4) {
+        INT32 v = *in++;
+        memcpy(out_, &v, sizeof(v));
+    }
 }
 
 static void
 i2l(UINT8* out, const UINT8* in_, int xsize)
 {
     int x;
-    INT32* in = (INT32*) in_;
-    for (x = 0; x < xsize; x++, in++, out++) {
-        if (*in <= 0)
+    for (x = 0; x < xsize; x++, out++, in_ += 4) {
+        INT32 v;
+        memcpy(&v, in_, sizeof(v));
+        if (v <= 0)
             *out = 0;
-        else if (*in >= 255)
+        else if (v >= 255)
             *out = 255;
         else
-            *out = (UINT8) *in;
+            *out = (UINT8) v;
     }
 }
 
@@ -587,10 +595,13 @@ static void
 i2f(UINT8* out_, const UINT8* in_, int xsize)
 {
     int x;
-    INT32* in = (INT32*) in_;
-    FLOAT32* out = (FLOAT32*) out_;
-    for (x = 0; x < xsize; x++)
-        *out++ = (FLOAT32) *in++;
+    for (x = 0; x < xsize; x++, in_ += 4, out_ += 4) {
+        INT32 i;
+        FLOAT32 f;
+        memcpy(&i, in_, sizeof(i));
+        f = i;
+        memcpy(out_, &f, sizeof(f));
+    }
 }
 
 /* ------------- */
@@ -601,32 +612,35 @@ static void
 bit2f(UINT8* out_, const UINT8* in, int xsize)
 {
     int x;
-    FLOAT32* out = (FLOAT32*) out_;
-    for (x = 0; x < xsize; x++)
-        *out++ = (*in++ != 0) ? 255.0F : 0.0F;
+    for (x = 0; x < xsize; x++, out_ += 4) {
+        FLOAT32 f = (*in++ != 0) ? 255.0F : 0.0F;
+        memcpy(out_, &f, sizeof(f));
+    }
 }
 
 static void
 l2f(UINT8* out_, const UINT8* in, int xsize)
 {
     int x;
-    FLOAT32* out = (FLOAT32*) out_;
-    for (x = 0; x < xsize; x++)
-        *out++ = (FLOAT32) *in++;
+    for (x = 0; x < xsize; x++, out_ += 4) {
+        FLOAT32 f = (FLOAT32) *in++;
+        memcpy(out_, &f, sizeof(f));
+    }
 }
 
 static void
 f2l(UINT8* out, const UINT8* in_, int xsize)
 {
     int x;
-    FLOAT32* in = (FLOAT32*) in_;
-    for (x = 0; x < xsize; x++, in++, out++) {
-        if (*in <= 0.0)
+    for (x = 0; x < xsize; x++, out++, in_ += 4) {
+        FLOAT32 v;
+        memcpy(&v, in_, sizeof(v));
+        if (v <= 0.0)
             *out = 0;
-        else if (*in >= 255.0)
+        else if (v >= 255.0)
             *out = 255;
         else
-            *out = (UINT8) *in;
+            *out = (UINT8) v;
     }
 }
 
@@ -634,10 +648,13 @@ static void
 f2i(UINT8* out_, const UINT8* in_, int xsize)
 {
     int x;
-    FLOAT32* in = (FLOAT32*) in_;
-    INT32* out = (INT32*) out_;
-    for (x = 0; x < xsize; x++)
-        *out++ = (INT32) *in++;
+    for (x = 0; x < xsize; x++, in_ += 4, out_ += 4) {
+        FLOAT32 f;
+        INT32 i;
+        memcpy(&f, in_, sizeof(f));
+        i = f;
+        memcpy(out_, &i, sizeof(i));
+    }
 }
 
 /* ----------------- */
@@ -674,9 +691,10 @@ static void
 I_I16L(UINT8* out, const UINT8* in_, int xsize)
 {
     int x, v;
-    INT32* in = (INT32*) in_;
-    for (x = 0; x < xsize; x++, in++) {
-        v = CLIP16(*in);
+    for (x = 0; x < xsize; x++, in_ += 4) {
+        INT32 i;
+        memcpy(&i, in_, sizeof(i));
+        v = CLIP16(i);
         *out++ = (UINT8) v;
         *out++ = (UINT8) (v >> 8);
     }
@@ -686,9 +704,10 @@ static void
 I_I16B(UINT8* out, const UINT8* in_, int xsize)
 {
     int x, v;
-    INT32* in = (INT32*) in_;
-    for (x = 0; x < xsize; x++, in++) {
-        v = CLIP16(*in);
+    for (x = 0; x < xsize; x++, in_ += 4) {
+        INT32 i;
+        memcpy(&i, in_, sizeof(i));
+        v = CLIP16(i);
         *out++ = (UINT8) (v >> 8);
         *out++ = (UINT8) v;
     }
@@ -699,9 +718,10 @@ static void
 I16L_I(UINT8* out_, const UINT8* in, int xsize)
 {
     int x;
-    INT32* out = (INT32*) out_;
-    for (x = 0; x < xsize; x++, in += 2)
-        *out++ = in[0] + ((int) in[1] << 8);
+    for (x = 0; x < xsize; x++, in += 2, out_ += 4) {
+        INT32 v = in[0] + ((int) in[1] << 8);
+        memcpy(out_, &v, sizeof(v));
+    }
 }
 
 
@@ -709,18 +729,20 @@ static void
 I16B_I(UINT8* out_, const UINT8* in, int xsize)
 {
     int x;
-    INT32* out = (INT32*) out_;
-    for (x = 0; x < xsize; x++, in += 2)
-        *out++ = in[1] + ((int) in[0] << 8);
+    for (x = 0; x < xsize; x++, in += 2, out_ += 4) {
+        INT32 v = in[1] + ((int) in[0] << 8);
+        memcpy(out_, &v, sizeof(v));
+    }
 }
 
 static void
 I16L_F(UINT8* out_, const UINT8* in, int xsize)
 {
     int x;
-    FLOAT32* out = (FLOAT32*) out_;
-    for (x = 0; x < xsize; x++, in += 2)
-        *out++ = (FLOAT32) (in[0] + ((int) in[1] << 8));
+    for (x = 0; x < xsize; x++, in += 2, out_ += 4) {
+        FLOAT32 v = in[0] + ((int) in[1] << 8);
+        memcpy(out_, &v, sizeof(v));
+    }
 }
 
 
@@ -728,9 +750,10 @@ static void
 I16B_F(UINT8* out_, const UINT8* in, int xsize)
 {
     int x;
-    FLOAT32* out = (FLOAT32*) out_;
-    for (x = 0; x < xsize; x++, in += 2)
-        *out++ = (FLOAT32) (in[1] + ((int) in[0] << 8));
+    for (x = 0; x < xsize; x++, in += 2, out_ += 4) {
+        FLOAT32 v = in[1] + ((int) in[0] << 8);
+        memcpy(out_, &v, sizeof(v));
+    }
 }
 
 static void
@@ -931,18 +954,20 @@ static void
 p2i(UINT8* out_, const UINT8* in, int xsize, const UINT8* palette)
 {
     int x;
-    INT32* out = (INT32*) out_;
-    for (x = 0; x < xsize; x++)
-        *out++ = L(&palette[in[x]*4]) / 1000;
+    for (x = 0; x < xsize; x++, in += 2, out_ += 4) {
+        INT32 v = L(&palette[in[x]*4]) / 1000;
+        memcpy(out_, &v, sizeof(v));
+    }
 }
 
 static void
 p2f(UINT8* out_, const UINT8* in, int xsize, const UINT8* palette)
 {
     int x;
-    FLOAT32* out = (FLOAT32*) out_;
-    for (x = 0; x < xsize; x++)
-        *out++ = (float) L(&palette[in[x]*4]) / 1000.0F;
+    for (x = 0; x < xsize; x++, in += 2, out_ += 4) {
+        FLOAT32 v = L(&palette[in[x]*4]) / 1000.0F;
+        memcpy(out_, &v, sizeof(v));
+    }
 }
 
 static void
--- Pillow-5.1.0/src/libImaging/Filter.c
+++ Pillow-5.1.0/src/libImaging/Filter.c
@@ -122,26 +122,29 @@ ImagingFilter3x3(Imaging imOut, Imaging
             UINT8* in_1 = (UINT8*) im->image[y-1];
             UINT8* in0 = (UINT8*) im->image[y];
             UINT8* in1 = (UINT8*) im->image[y+1];
-            UINT32* out = (UINT32*) imOut->image[y];
+            UINT8* out = (UINT8*) imOut->image[y];
 
-            out[0] = ((UINT32*) in0)[0];
+            memcpy(out, in0, sizeof(UINT32));
             if (im->bands == 2) {
                 for (x = 1; x < im->xsize-1; x++) {
                     float ss0 = offset;
                     float ss3 = offset;
+                    UINT32 v;
                     ss0 += KERNEL1x3(in1, x*4+0, &kernel[0], 4);
                     ss3 += KERNEL1x3(in1, x*4+3, &kernel[0], 4);
                     ss0 += KERNEL1x3(in0, x*4+0, &kernel[3], 4);
                     ss3 += KERNEL1x3(in0, x*4+3, &kernel[3], 4);
                     ss0 += KERNEL1x3(in_1, x*4+0, &kernel[6], 4);
                     ss3 += KERNEL1x3(in_1, x*4+3, &kernel[6], 4);
-                    out[x] = MAKE_UINT32(clip8(ss0), 0, 0, clip8(ss3));
+                    v = MAKE_UINT32(clip8(ss0), 0, 0, clip8(ss3));
+                    memcpy(out + x * sizeof(v), &v, sizeof(v));
                 }
             } else if (im->bands == 3) {
                 for (x = 1; x < im->xsize-1; x++) {
                     float ss0 = offset;
                     float ss1 = offset;
                     float ss2 = offset;
+                    UINT32 v;
                     ss0 += KERNEL1x3(in1, x*4+0, &kernel[0], 4);
                     ss1 += KERNEL1x3(in1, x*4+1, &kernel[0], 4);
                     ss2 += KERNEL1x3(in1, x*4+2, &kernel[0], 4);
@@ -151,8 +154,9 @@ ImagingFilter3x3(Imaging imOut, Imaging
                     ss0 += KERNEL1x3(in_1, x*4+0, &kernel[6], 4);
                     ss1 += KERNEL1x3(in_1, x*4+1, &kernel[6], 4);
                     ss2 += KERNEL1x3(in_1, x*4+2, &kernel[6], 4);
-                    out[x] = MAKE_UINT32(
+                    v = MAKE_UINT32(
                         clip8(ss0), clip8(ss1), clip8(ss2), 0);
+                    memcpy(out + x * sizeof(v), &v, sizeof(v));
                 }
             } else if (im->bands == 4) {
                 for (x = 1; x < im->xsize-1; x++) {
@@ -160,6 +164,7 @@ ImagingFilter3x3(Imaging imOut, Imaging
                     float ss1 = offset;
                     float ss2 = offset;
                     float ss3 = offset;
+                    UINT32 v;
                     ss0 += KERNEL1x3(in1, x*4+0, &kernel[0], 4);
                     ss1 += KERNEL1x3(in1, x*4+1, &kernel[0], 4);
                     ss2 += KERNEL1x3(in1, x*4+2, &kernel[0], 4);
@@ -172,11 +177,12 @@ ImagingFilter3x3(Imaging imOut, Imaging
                     ss1 += KERNEL1x3(in_1, x*4+1, &kernel[6], 4);
                     ss2 += KERNEL1x3(in_1, x*4+2, &kernel[6], 4);
                     ss3 += KERNEL1x3(in_1, x*4+3, &kernel[6], 4);
-                    out[x] = MAKE_UINT32(
+                    v = MAKE_UINT32(
                         clip8(ss0), clip8(ss1), clip8(ss2), clip8(ss3));
+                    memcpy(out + x * sizeof(v), &v, sizeof(v));
                 }
             }
-            out[x] = ((UINT32*) in0)[x];
+            memcpy(out + x * sizeof(UINT32), in0 + x * sizeof(UINT32), sizeof(UINT32));
         }
     }
     memcpy(imOut->image[y], im->image[y], im->linesize);
@@ -232,14 +238,14 @@ ImagingFilter5x5(Imaging imOut, Imaging
             UINT8* in0 = (UINT8*) im->image[y];
             UINT8* in1 = (UINT8*) im->image[y+1];
             UINT8* in2 = (UINT8*) im->image[y+2];
-            UINT32* out = (UINT32*) imOut->image[y];
+            UINT8* out = (UINT8*) imOut->image[y];
 
-            out[0] = ((UINT32*) in0)[0];
-            out[1] = ((UINT32*) in0)[1];
+            memcpy(out, in0, sizeof(UINT32) * 2);
             if (im->bands == 2) {
                 for (x = 2; x < im->xsize-2; x++) {
                     float ss0 = offset;
                     float ss3 = offset;
+                    UINT32 v;
                     ss0 += KERNEL1x5(in2, x*4+0, &kernel[0], 4);
                     ss3 += KERNEL1x5(in2, x*4+3, &kernel[0], 4);
                     ss0 += KERNEL1x5(in1, x*4+0, &kernel[5], 4);
@@ -250,13 +256,15 @@ ImagingFilter5x5(Imaging imOut, Imaging
                     ss3 += KERNEL1x5(in_1, x*4+3, &kernel[15], 4);
                     ss0 += KERNEL1x5(in_2, x*4+0, &kernel[20], 4);
                     ss3 += KERNEL1x5(in_2, x*4+3, &kernel[20], 4);
-                    out[x] = MAKE_UINT32(clip8(ss0), 0, 0, clip8(ss3));
+                    v = MAKE_UINT32(clip8(ss0), 0, 0, clip8(ss3));
+                    memcpy(out + x * sizeof(v), &v, sizeof(v));
                 }
             } else if (im->bands == 3) {
                 for (x = 2; x < im->xsize-2; x++) {
                     float ss0 = offset;
                     float ss1 = offset;
                     float ss2 = offset;
+                    UINT32 v;
                     ss0 += KERNEL1x5(in2, x*4+0, &kernel[0], 4);
                     ss1 += KERNEL1x5(in2, x*4+1, &kernel[0], 4);
                     ss2 += KERNEL1x5(in2, x*4+2, &kernel[0], 4);
@@ -272,8 +280,9 @@ ImagingFilter5x5(Imaging imOut, Imaging
                     ss0 += KERNEL1x5(in_2, x*4+0, &kernel[20], 4);
                     ss1 += KERNEL1x5(in_2, x*4+1, &kernel[20], 4);
                     ss2 += KERNEL1x5(in_2, x*4+2, &kernel[20], 4);
-                    out[x] = MAKE_UINT32(
+                    v = MAKE_UINT32(
                         clip8(ss0), clip8(ss1), clip8(ss2), 0);
+                    memcpy(out + x * sizeof(v), &v, sizeof(v));
                 }
             } else if (im->bands == 4) {
                 for (x = 2; x < im->xsize-2; x++) {
@@ -281,6 +290,7 @@ ImagingFilter5x5(Imaging imOut, Imaging
                     float ss1 = offset;
                     float ss2 = offset;
                     float ss3 = offset;
+                    UINT32 v;
                     ss0 += KERNEL1x5(in2, x*4+0, &kernel[0], 4);
                     ss1 += KERNEL1x5(in2, x*4+1, &kernel[0], 4);
                     ss2 += KERNEL1x5(in2, x*4+2, &kernel[0], 4);
@@ -301,12 +311,12 @@ ImagingFilter5x5(Imaging imOut, Imaging
                     ss1 += KERNEL1x5(in_2, x*4+1, &kernel[20], 4);
                     ss2 += KERNEL1x5(in_2, x*4+2, &kernel[20], 4);
                     ss3 += KERNEL1x5(in_2, x*4+3, &kernel[20], 4);
-                    out[x] = MAKE_UINT32(
+                    v = MAKE_UINT32(
                         clip8(ss0), clip8(ss1), clip8(ss2), clip8(ss3));
+                    memcpy(out + x * sizeof(v), &v, sizeof(v));
                 }
             }
-            out[x] = ((UINT32*) in0)[x];
-            out[x+1] = ((UINT32*) in0)[x+1];
+            memcpy(out + x * sizeof(UINT32), in0 + x * sizeof(UINT32), sizeof(UINT32) * 2);
         }
     }
     memcpy(imOut->image[y], im->image[y], im->linesize);
--- Pillow-5.1.0/src/libImaging/Geometry.c
+++ Pillow-5.1.0/src/libImaging/Geometry.c
@@ -396,7 +396,7 @@ nearest_filter16(void* out, Imaging im,
     int y = COORD(yin);
     if (x < 0 || x >= im->xsize || y < 0 || y >= im->ysize)
         return 0;
-    ((INT16*)out)[0] = ((INT16*)(im->image8[y]))[x];
+    memcpy(out, im->image8[y] + x * sizeof(INT16), sizeof(INT16));
     return 1;
 }
 
@@ -457,18 +457,22 @@ bilinear_filter8(void* out, Imaging im,
 static int
 bilinear_filter32I(void* out, Imaging im, double xin, double yin)
 {
+    INT32 k;
     BILINEAR_HEAD(INT32);
     BILINEAR_BODY(INT32, im->image32, 1, 0);
-    ((INT32*)out)[0] = (INT32) v1;
+    k = v1;
+    memcpy(out, &k, sizeof(k));
     return 1;
 }
 
 static int
 bilinear_filter32F(void* out, Imaging im, double xin, double yin)
 {
+    FLOAT32 k;
     BILINEAR_HEAD(FLOAT32);
     BILINEAR_BODY(FLOAT32, im->image32, 1, 0);
-    ((FLOAT32*)out)[0] = (FLOAT32) v1;
+    k = v1;
+    memcpy(out, &k, sizeof(k));
     return 1;
 }
 
@@ -569,18 +573,22 @@ bicubic_filter8(void* out, Imaging im, d
 static int
 bicubic_filter32I(void* out, Imaging im, double xin, double yin)
 {
+    INT32 k;
     BICUBIC_HEAD(INT32);
     BICUBIC_BODY(INT32, im->image32, 1, 0);
-    ((INT32*)out)[0] = (INT32) v1;
+    k = v1;
+    memcpy(out, &k, sizeof(k));
     return 1;
 }
 
 static int
 bicubic_filter32F(void* out, Imaging im, double xin, double yin)
 {
+    FLOAT32 k;
     BICUBIC_HEAD(FLOAT32);
     BICUBIC_BODY(FLOAT32, im->image32, 1, 0);
-    ((FLOAT32*)out)[0] = (FLOAT32) v1;
+    k = v1;
+    memcpy(out, &k, sizeof(k));
     return 1;
 }
 
--- Pillow-5.1.0/src/libImaging/GetBBox.c
+++ Pillow-5.1.0/src/libImaging/GetBBox.c
@@ -146,8 +146,8 @@ ImagingGetExtrema(Imaging im, void *extr
                     imax = in[x];
             }
         }
-        ((INT32*) extrema)[0] = imin;
-        ((INT32*) extrema)[1] = imax;
+        memcpy(extrema, &imin, sizeof(imin));
+        memcpy(((char*)extrema) + sizeof(imin), &imax, sizeof(imax));
         break;
     case IMAGING_TYPE_FLOAT32:
         fmin = fmax = ((FLOAT32*) im->image32[0])[0];
@@ -160,23 +160,27 @@ ImagingGetExtrema(Imaging im, void *extr
                     fmax = in[x];
             }
         }
-        ((FLOAT32*) extrema)[0] = fmin;
-        ((FLOAT32*) extrema)[1] = fmax;
+        memcpy(extrema, &fmin, sizeof(fmin));
+        memcpy(((char*)extrema) + sizeof(fmin), &fmax, sizeof(fmax));
         break;
     case IMAGING_TYPE_SPECIAL:
       if (strcmp(im->mode, "I;16") == 0) {
-          imin = imax = ((UINT16*) im->image8[0])[0];
+          UINT16 v;
+          memcpy(&v, *im->image8, sizeof(v));
+          imin = imax = v;
           for (y = 0; y < im->ysize; y++) {
-              UINT16* in = (UINT16 *) im->image[y];
               for (x = 0; x < im->xsize; x++) {
-                  if (imin > in[x])
-                      imin = in[x];
-                  else if (imax < in[x])
-                      imax = in[x];
+                  memcpy(&v, im->image[y] + x * sizeof(v), sizeof(v));
+                  if (imin > v)
+                      imin = v;
+                  else if (imax < v)
+                      imax = v;
               }
           }
-          ((UINT16*) extrema)[0] = (UINT16) imin;
-          ((UINT16*) extrema)[1] = (UINT16) imax;
+          v = (UINT16) imin;
+          memcpy(extrema, &v, sizeof(v));
+          v = (UINT16) imax;
+          memcpy(((char*)extrema) + sizeof(v), &v, sizeof(v));
 	  break;
       }
       /* FALL THROUGH */
--- Pillow-5.1.0/src/libImaging/Histo.c
+++ Pillow-5.1.0/src/libImaging/Histo.c
@@ -124,8 +124,8 @@ ImagingGetHistogram(Imaging im, Imaging
                     return ImagingError_ValueError("min/max not given");
                 if (!im->xsize || !im->ysize)
                     break;
-                imin = ((INT32*) minmax)[0];
-                imax = ((INT32*) minmax)[1];
+                memcpy(&imin, minmax, sizeof(imin));
+                memcpy(&imax, ((char*)minmax) + sizeof(imin), sizeof(imax));
                 if (imin >= imax)
                     break;
                 ImagingSectionEnter(&cookie);
@@ -145,8 +145,8 @@ ImagingGetHistogram(Imaging im, Imaging
                     return ImagingError_ValueError("min/max not given");
                 if (!im->xsize || !im->ysize)
                     break;
-                fmin = ((FLOAT32*) minmax)[0];
-                fmax = ((FLOAT32*) minmax)[1];
+                memcpy(&fmin, minmax, sizeof(fmin));
+                memcpy(&fmax, ((char*)minmax) + sizeof(fmin), sizeof(fmax));
                 if (fmin >= fmax)
                     break;
                 ImagingSectionEnter(&cookie);
--- Pillow-5.1.0/src/libImaging/Pack.c
+++ Pillow-5.1.0/src/libImaging/Pack.c
@@ -261,7 +261,7 @@ ImagingPackRGB(UINT8* out, const UINT8* in, int pixels)
     }
 #else
     for (; i < pixels-1; i++) {
-        ((UINT32*)out)[0] = ((UINT32*)in)[i];
+        memcpy(out, in + i * 4, 4);
         out += 3;
     }
     for (; i < pixels; i++) {
@@ -402,18 +402,19 @@ static void
 packI16B(UINT8* out, const UINT8* in_, int pixels)
 {
     int i;
-    INT32* in = (INT32*) in_;
     UINT16 tmp_;
     UINT8* tmp = (UINT8*) &tmp_;
     for (i = 0; i < pixels; i++) {
-        if (in[0] <= 0)
+        INT32 in;
+        memcpy(&in, in_, sizeof(in));
+        if (in <= 0)
             tmp_ = 0;
-        else if (in[0] > 65535)
+        else if (in > 65535)
             tmp_ = 65535;
         else
-            tmp_ = in[0];
+            tmp_ = in;
         C16B;
-        out += 2; in++;
+        out += 2; in_ += sizeof(in);
     }
 }
 
--- Pillow-5.1.0/src/libImaging/Point.c
+++ Pillow-5.1.0/src/libImaging/Point.c
@@ -99,12 +99,12 @@ im_point_8_32(Imaging imOut, Imaging imIn, im_point_context* context)
 {
     int x, y;
     /* 8-bit source, 32-bit destination */
-    INT32* table = (INT32*) context->table;
+    char* table = (char*) context->table;
     for (y = 0; y < imIn->ysize; y++) {
         UINT8* in = imIn->image8[y];
         INT32* out = imOut->image32[y];
         for (x = 0; x < imIn->xsize; x++)
-            out[x] = table[in[x]];
+            memcpy(out + x, table + in[x] * sizeof(INT32), sizeof(INT32));
     }
 }
 
@@ -242,11 +242,15 @@ ImagingPointTransform(Imaging imIn, double scale, double offset)
         if (strcmp(imIn->mode,"I;16") == 0) {
             ImagingSectionEnter(&cookie);
             for (y = 0; y < imIn->ysize; y++) {
-                UINT16* in  = (UINT16 *)imIn->image[y];
-                UINT16* out = (UINT16 *)imOut->image[y];
+                char* in  = (char*)imIn->image[y];
+                char* out = (char*)imOut->image[y];
                 /* FIXME: add clipping? */
-                for (x = 0; x < imIn->xsize; x++)
-                    out[x] = in[x] * scale + offset;
+                for (x = 0; x < imIn->xsize; x++) {
+                    UINT16 v;
+                    memcpy(&v, in + x * sizeof(v), sizeof(v));
+                    v = v * scale + offset;
+                    memcpy(out + x * sizeof(UINT16), &v, sizeof(v));
+                }
             }
             ImagingSectionLeave(&cookie);
             break;
--- Pillow-5.1.0/src/libImaging/Resample.c
+++ Pillow-5.1.0/src/libImaging/Resample.c
@@ -256,6 +256,7 @@ ImagingResampleHorizontal_8bpc(Imaging i
         if (imIn->bands == 2) {
             for (yy = 0; yy < imOut->ysize; yy++) {
                 for (xx = 0; xx < imOut->xsize; xx++) {
+                    UINT32 v;
                     xmin = bounds[xx * 2 + 0];
                     xmax = bounds[xx * 2 + 1];
                     k = &kk[xx * ksize];
@@ -264,13 +265,14 @@ ImagingResampleHorizontal_8bpc(Imaging i
                         ss0 += ((UINT8) imIn->image[yy + offset][(x + xmin)*4 + 0]) * k[x];
                         ss3 += ((UINT8) imIn->image[yy + offset][(x + xmin)*4 + 3]) * k[x];
                     }
-                    ((UINT32 *) imOut->image[yy])[xx] = MAKE_UINT32(
-                        clip8(ss0), 0, 0, clip8(ss3));
+                    v = MAKE_UINT32(clip8(ss0), 0, 0, clip8(ss3));
+                    memcpy(imOut->image[yy] + xx * sizeof(v), &v, sizeof(v));
                 }
             }
         } else if (imIn->bands == 3) {
             for (yy = 0; yy < imOut->ysize; yy++) {
                 for (xx = 0; xx < imOut->xsize; xx++) {
+                    UINT32 v;
                     xmin = bounds[xx * 2 + 0];
                     xmax = bounds[xx * 2 + 1];
                     k = &kk[xx * ksize];
@@ -280,13 +282,14 @@ ImagingResampleHorizontal_8bpc(Imaging i
                         ss1 += ((UINT8) imIn->image[yy + offset][(x + xmin)*4 + 1]) * k[x];
                         ss2 += ((UINT8) imIn->image[yy + offset][(x + xmin)*4 + 2]) * k[x];
                     }
-                    ((UINT32 *) imOut->image[yy])[xx] = MAKE_UINT32(
-                        clip8(ss0), clip8(ss1), clip8(ss2), 0);
+                    v = MAKE_UINT32(clip8(ss0), clip8(ss1), clip8(ss2), 0);
+                    memcpy(imOut->image[yy] + xx * sizeof(v), &v, sizeof(v));
                 }
             }
         } else {
             for (yy = 0; yy < imOut->ysize; yy++) {
                 for (xx = 0; xx < imOut->xsize; xx++) {
+                    UINT32 v;
                     xmin = bounds[xx * 2 + 0];
                     xmax = bounds[xx * 2 + 1];
                     k = &kk[xx * ksize];
@@ -297,8 +300,8 @@ ImagingResampleHorizontal_8bpc(Imaging i
                         ss2 += ((UINT8) imIn->image[yy + offset][(x + xmin)*4 + 2]) * k[x];
                         ss3 += ((UINT8) imIn->image[yy + offset][(x + xmin)*4 + 3]) * k[x];
                     }
-                    ((UINT32 *) imOut->image[yy])[xx] = MAKE_UINT32(
-                        clip8(ss0), clip8(ss1), clip8(ss2), clip8(ss3));
+                    v = MAKE_UINT32(clip8(ss0), clip8(ss1), clip8(ss2), clip8(ss3));
+                    memcpy(imOut->image[yy] + xx * sizeof(v), &v, sizeof(v));
                 }
             }
         }
@@ -340,13 +343,14 @@ ImagingResampleVertical_8bpc(Imaging imO
                 ymin = bounds[yy * 2 + 0];
                 ymax = bounds[yy * 2 + 1];
                 for (xx = 0; xx < imOut->xsize; xx++) {
+                    UINT32 v;
                     ss0 = ss3 = 1 << (PRECISION_BITS -1);
                     for (y = 0; y < ymax; y++) {
                         ss0 += ((UINT8) imIn->image[y + ymin][xx*4 + 0]) * k[y];
                         ss3 += ((UINT8) imIn->image[y + ymin][xx*4 + 3]) * k[y];
                     }
-                    ((UINT32 *) imOut->image[yy])[xx] = MAKE_UINT32(
-                        clip8(ss0), 0, 0, clip8(ss3));
+                    v = MAKE_UINT32(clip8(ss0), 0, 0, clip8(ss3));
+                    memcpy(imOut->image[yy] + xx * sizeof(v), &v, sizeof(v));
                 }
             }
         } else if (imIn->bands == 3) {
@@ -355,14 +359,15 @@ ImagingResampleVertical_8bpc(Imaging imO
                 ymin = bounds[yy * 2 + 0];
                 ymax = bounds[yy * 2 + 1];
                 for (xx = 0; xx < imOut->xsize; xx++) {
+                    UINT32 v;
                     ss0 = ss1 = ss2 = 1 << (PRECISION_BITS -1);
                     for (y = 0; y < ymax; y++) {
                         ss0 += ((UINT8) imIn->image[y + ymin][xx*4 + 0]) * k[y];
                         ss1 += ((UINT8) imIn->image[y + ymin][xx*4 + 1]) * k[y];
                         ss2 += ((UINT8) imIn->image[y + ymin][xx*4 + 2]) * k[y];
                     }
-                    ((UINT32 *) imOut->image[yy])[xx] = MAKE_UINT32(
-                        clip8(ss0), clip8(ss1), clip8(ss2), 0);
+                    v = MAKE_UINT32(clip8(ss0), clip8(ss1), clip8(ss2), 0);
+                    memcpy(imOut->image[yy] + xx * sizeof(v), &v, sizeof(v));
                 }
             }
         } else {
@@ -371,6 +376,7 @@ ImagingResampleVertical_8bpc(Imaging imO
                 ymin = bounds[yy * 2 + 0];
                 ymax = bounds[yy * 2 + 1];
                 for (xx = 0; xx < imOut->xsize; xx++) {
+                    UINT32 v;
                     ss0 = ss1 = ss2 = ss3 = 1 << (PRECISION_BITS -1);
                     for (y = 0; y < ymax; y++) {
                         ss0 += ((UINT8) imIn->image[y + ymin][xx*4 + 0]) * k[y];
@@ -378,8 +384,8 @@ ImagingResampleVertical_8bpc(Imaging imO
                         ss2 += ((UINT8) imIn->image[y + ymin][xx*4 + 2]) * k[y];
                         ss3 += ((UINT8) imIn->image[y + ymin][xx*4 + 3]) * k[y];
                     }
-                    ((UINT32 *) imOut->image[yy])[xx] = MAKE_UINT32(
-                        clip8(ss0), clip8(ss1), clip8(ss2), clip8(ss3));
+                    v = MAKE_UINT32(clip8(ss0), clip8(ss1), clip8(ss2), clip8(ss3));
+                    memcpy(imOut->image[yy] + xx * sizeof(v), &v, sizeof(v));
                 }
             }
         }
--- a/src/libImaging/SgiRleDecode.c
+++ b/src/libImaging/SgiRleDecode.c
@@ -61,7 +61,7 @@
     return 0;
 }
 
-static int expandrow2(UINT16* dest, UINT16* src, int n, int z, int xsize)
+static int expandrow2(UINT8* dest, const UINT8* src, int n, int z, int xsize)
 {
     UINT8 pixel, count;
 
@@ -69,8 +69,8 @@
 
     for (;n > 0; n--)
     {
-        pixel = ((UINT8*)src)[1];
-        ++src;
+        pixel = src[1];
+        src+=2;
         if (n == 1 && pixel != 0)
             return n;
         count = pixel & RLE_MAX_RUN;
@@ -82,16 +82,17 @@ static int expandrow2(UINT16* dest, UINT16* src, int n, int z)
         x += count;
         if (pixel & RLE_COPY_FLAG) {
             while(count--) {
-                *dest = *src++;
-                dest += z;
+                memcpy(dest, src, 2);
+                src += 2;
+                dest += z * 2;
             }
         }
         else {
             while (count--) {
-                *dest = *src;
-                dest += z;
+                memcpy(dest, src, 2);
+                dest += z * 2;
             }
-            ++src;
+            src+=2;
         }
     }
     return 0;
@@ -177,7 +177,7 @@
                 status = expandrow(&state->buffer[c->channo], &ptr[c->rleoffset], c->rlelength, im->bands, im->xsize);
             }
             else {
-                status = expandrow2((UINT16*)&state->buffer[c->channo * 2], (UINT16*)&ptr[c->rleoffset], c->rlelength, im->bands, im->xsize);
+                status = expandrow2(&state->buffer[c->channo * 2], &ptr[c->rleoffset], c->rlelength, im->bands, im->xsize);
             }
             if (status == -1) {
                 state->errcode = IMAGING_CODEC_OVERRUN;
--- a/src/libImaging/Unpack.c
+++ b/src/libImaging/Unpack.c
@@ -32,7 +32,6 @@
 
 #include "Imaging.h"
 
-
 #define R 0
 #define G 1
 #define B 2
@@ -329,11 +328,11 @@ static void
 unpackLA(UINT8* _out, const UINT8* in, int pixels)
 {
     int i;
-    UINT32* out = (UINT32*) _out;
     /* LA, pixel interleaved */
     for (i = 0; i < pixels; i++) {
-        out[i] = MAKE_UINT32(in[0], in[0], in[0], in[1]);
-        in += 2;
+        UINT32 iv = MAKE_UINT32(in[0], in[0], in[0], in[1]);
+        memcpy(_out, &iv, sizeof(iv));
+        in += 2; _out += 4;
     }
 }
 
@@ -341,10 +340,10 @@ static void
 unpackLAL(UINT8* _out, const UINT8* in, int pixels)
 {
     int i;
-    UINT32* out = (UINT32*) _out;
     /* LA, line interleaved */
-    for (i = 0; i < pixels; i++) {
-        out[i] = MAKE_UINT32(in[i], in[i], in[i], in[i+pixels]);
+    for (i = 0; i < pixels; i++, _out+=4) {
+        UINT32 iv = MAKE_UINT32(in[i], in[i], in[i], in[i+pixels]);
+        memcpy(_out, &iv, sizeof(iv));
     }
 }
 
@@ -482,38 +481,30 @@ void
 ImagingUnpackRGB(UINT8* _out, const UINT8* in, int pixels)
 {
     int i = 0;
-#ifdef __sparc
-    /* SPARC CPUs cannot read integers from nonaligned addresses. */
-    for (; i < pixels; i++) {
-        _out[R] = in[0];
-        _out[G] = in[1];
-        _out[B] = in[2];
-        _out[A] = 255;
-        _out += 4; in += 3;
-    }
-#else
-    UINT32* out = (UINT32*) _out;
     /* RGB triplets */
     for (; i < pixels-1; i++) {
-        out[i] = MASK_UINT32_CHANNEL_3 | *(UINT32*)&in[0];
-        in += 3;
+        UINT32 iv;
+        memcpy(&iv, in, sizeof(iv));
+        iv |= MASK_UINT32_CHANNEL_3;
+        memcpy(_out, &iv, sizeof(iv));
+        in += 3; _out += 4;
     }
     for (; i < pixels; i++) {
-        out[i] = MAKE_UINT32(in[0], in[1], in[2], 255);
-        in += 3;
+        UINT32 iv = MAKE_UINT32(in[0], in[1], in[2], 255);
+        memcpy(_out, &iv, sizeof(iv));
+        in += 3; _out += 4;
     }
-#endif
 }
 
 void
 unpackRGB16L(UINT8* _out, const UINT8* in, int pixels)
 {
     int i;
-    UINT32* out = (UINT32*) _out;
     /* 16-bit RGB triplets, little-endian order */
     for (i = 0; i < pixels; i++) {
-        out[i] = MAKE_UINT32(in[1], in[3], in[5], 255);
-        in += 6;
+        UINT32 iv = MAKE_UINT32(in[1], in[3], in[5], 255);
+        memcpy(_out, &iv, sizeof(iv));
+        in += 6; _out += 4;
     }
 }
 
@@ -521,11 +512,11 @@ void
 unpackRGB16B(UINT8* _out, const UINT8* in, int pixels)
 {
     int i;
-    UINT32* out = (UINT32*) _out;
     /* 16-bit RGB triplets, big-endian order */
     for (i = 0; i < pixels; i++) {
-        out[i] = MAKE_UINT32(in[0], in[2], in[4], 255);
-        in += 6;
+        UINT32 iv = MAKE_UINT32(in[0], in[2], in[4], 255);
+        memcpy(_out, &iv, sizeof(iv));
+        in += 6; _out += 4;
     }
 }
 
@@ -533,10 +524,10 @@ static void
 unpackRGBL(UINT8* _out, const UINT8* in, int pixels)
 {
     int i;
-    UINT32* out = (UINT32*) _out;
     /* RGB, line interleaved */
-    for (i = 0; i < pixels; i++) {
-        out[i] = MAKE_UINT32(in[i], in[i+pixels], in[i+pixels+pixels], 255);
+    for (i = 0; i < pixels; i++, _out+=4) {
+        UINT32 iv = MAKE_UINT32(in[i], in[i+pixels], in[i+pixels+pixels], 255);
+        memcpy(_out, &iv, sizeof(iv));
     }
 }
 
@@ -544,12 +535,12 @@ static void
 unpackRGBR(UINT8* _out, const UINT8* in, int pixels)
 {
     int i;
-    UINT32* out = (UINT32*) _out;
     /* RGB, bit reversed */
     for (i = 0; i < pixels; i++) {
-        out[i] = MAKE_UINT32(BITFLIP[in[0]], BITFLIP[in[1]],
-                             BITFLIP[in[2]], 255);
-        in += 3;
+        UINT32 iv = MAKE_UINT32(BITFLIP[in[0]], BITFLIP[in[1]],
+                                BITFLIP[in[2]], 255);
+        memcpy(_out, &iv, sizeof(iv));
+        in += 3; _out += 4;
     }
 }
 
@@ -557,11 +548,11 @@ void
 ImagingUnpackBGR(UINT8* _out, const UINT8* in, int pixels)
 {
     int i;
-    UINT32* out = (UINT32*) _out;
     /* RGB, reversed bytes */
     for (i = 0; i < pixels; i++) {
-        out[i] = MAKE_UINT32(in[2], in[1], in[0], 255);
-        in += 3;
+        UINT32 iv = MAKE_UINT32(in[2], in[1], in[0], 255);
+        memcpy(_out, &iv, sizeof(iv));
+        in += 3; _out += 4;
     }
 }
 
@@ -689,11 +680,11 @@ static void
 ImagingUnpackBGRX(UINT8* _out, const UINT8* in, int pixels)
 {
     int i;
-    UINT32* out = (UINT32*) _out;
     /* RGB, reversed bytes with padding */
     for (i = 0; i < pixels; i++) {
-        out[i] = MAKE_UINT32(in[2], in[1], in[0], 255);
-        in += 4;
+        UINT32 iv = MAKE_UINT32(in[2], in[1], in[0], 255);
+        memcpy(_out, &iv, sizeof(iv));
+        in += 4; _out += 4;
     }
 }
 
@@ -701,11 +692,11 @@ static void
 ImagingUnpackXRGB(UINT8* _out, const UINT8* in, int pixels)
 {
     int i;
-    UINT32* out = (UINT32*) _out;
     /* RGB, leading pad */
     for (i = 0; i < pixels; i++) {
-        out[i] = MAKE_UINT32(in[1], in[2], in[3], 255);
-        in += 4;
+        UINT32 iv = MAKE_UINT32(in[1], in[2], in[3], 255);
+        memcpy(_out, &iv, sizeof(iv));
+        in += 4; _out += 4;
     }
 }
 
@@ -713,11 +704,11 @@ static void
 ImagingUnpackXBGR(UINT8* _out, const UINT8* in, int pixels)
 {
     int i;
-    UINT32* out = (UINT32*) _out;
     /* RGB, reversed bytes, leading pad */
     for (i = 0; i < pixels; i++) {
-        out[i] = MAKE_UINT32(in[3], in[2], in[1], 255);
-        in += 4;
+        UINT32 iv = MAKE_UINT32(in[3], in[2], in[1], 255);
+        memcpy(_out, &iv, sizeof(iv));
+        in += 4; _out += 4;
     }
 }
 
@@ -727,11 +718,11 @@ static void
 unpackRGBALA(UINT8* _out, const UINT8* in, int pixels)
 {
     int i;
-    UINT32* out = (UINT32*) _out;
     /* greyscale with alpha */
     for (i = 0; i < pixels; i++) {
-        out[i] = MAKE_UINT32(in[0], in[0], in[0], in[1]);
-        in += 2;
+        UINT32 iv = MAKE_UINT32(in[0], in[0], in[0], in[1]);
+        memcpy(_out, &iv, sizeof(iv));
+        in += 2; _out += 4;
     }
 }
 
@@ -739,11 +730,11 @@ static void
 unpackRGBALA16B(UINT8* _out, const UINT8* in, int pixels)
 {
     int i;
-    UINT32* out = (UINT32*) _out;
     /* 16-bit greyscale with alpha, big-endian */
     for (i = 0; i < pixels; i++) {
-        out[i] = MAKE_UINT32(in[0], in[0], in[0], in[2]);
-        in += 4;
+        UINT32 iv = MAKE_UINT32(in[0], in[0], in[0], in[2]);
+        memcpy(_out, &iv, sizeof(iv));
+        in += 4; _out += 4;
     }
 }
 
@@ -751,20 +753,21 @@ static void
 unpackRGBa16L(UINT8* _out, const UINT8* in, int pixels)
 {
     int i;
-    UINT32* out = (UINT32*) _out;
     /* premultiplied 16-bit RGBA, little-endian */
     for (i = 0; i < pixels; i++) {
         int a = in[7];
+        UINT32 iv;
         if ( ! a) {
-            out[i] = 0;
+            iv = 0;
         } else if (a == 255) {
-            out[i] = MAKE_UINT32(in[1], in[3], in[5], a);
+            iv = MAKE_UINT32(in[1], in[3], in[5], a);
         } else {
-            out[i] = MAKE_UINT32(CLIP(in[1] * 255 / a),
-                                 CLIP(in[3] * 255 / a),
-                                 CLIP(in[5] * 255 / a), a);
+            iv = MAKE_UINT32(CLIP(in[1] * 255 / a),
+                             CLIP(in[3] * 255 / a),
+                             CLIP(in[5] * 255 / a), a);
         }
-        in += 8;
+        memcpy(_out, &iv, sizeof(iv));
+        in += 8; _out += 4;
     }
 }
 
@@ -772,20 +775,21 @@ static void
 unpackRGBa16B(UINT8* _out, const UINT8* in, int pixels)
 {
     int i;
-    UINT32* out = (UINT32*) _out;
     /* premultiplied 16-bit RGBA, big-endian */
     for (i = 0; i < pixels; i++) {
         int a = in[6];
+        UINT32 iv;
         if ( ! a) {
-            out[i] = 0;
+            iv = 0;
         } else if (a == 255) {
-            out[i] = MAKE_UINT32(in[0], in[2], in[4], a);
+            iv = MAKE_UINT32(in[0], in[2], in[4], a);
         } else {
-            out[i] = MAKE_UINT32(CLIP(in[0] * 255 / a),
-                                 CLIP(in[2] * 255 / a),
-                                 CLIP(in[4] * 255 / a), a);
+            iv = MAKE_UINT32(CLIP(in[0] * 255 / a),
+                             CLIP(in[2] * 255 / a),
+                             CLIP(in[4] * 255 / a), a);
         }
-        in += 8;
+        memcpy(_out, &iv, sizeof(iv));
+        in += 8; _out += 4;
     }
 }
 
@@ -793,20 +797,21 @@ static void
 unpackRGBa(UINT8* _out, const UINT8* in, int pixels)
 {
     int i;
-    UINT32* out = (UINT32*) _out;
     /* premultiplied RGBA */
     for (i = 0; i < pixels; i++) {
         int a = in[3];
+        UINT32 iv;
         if ( ! a) {
-            out[i] = 0;
+            iv = 0;
         } else if (a == 255) {
-            out[i] = MAKE_UINT32(in[0], in[1], in[2], a);
+            iv = MAKE_UINT32(in[0], in[1], in[2], a);
         } else {
-            out[i] = MAKE_UINT32(CLIP(in[0] * 255 / a),
-                                 CLIP(in[1] * 255 / a),
-                                 CLIP(in[2] * 255 / a), a);
+            iv = MAKE_UINT32(CLIP(in[0] * 255 / a),
+                             CLIP(in[1] * 255 / a),
+                             CLIP(in[2] * 255 / a), a);
         }
-        in += 4;
+        memcpy(_out, &iv, sizeof(iv));
+        in += 4; _out += 4;
     }
 }
 
@@ -814,20 +819,21 @@ static void
 unpackBGRa(UINT8* _out, const UINT8* in, int pixels)
 {
     int i;
-    UINT32* out = (UINT32*) _out;
     /* premultiplied BGRA */
     for (i = 0; i < pixels; i++) {
         int a = in[3];
+        UINT32 iv;
         if ( ! a) {
-            out[i] = 0;
+            iv = 0;
         } else if (a == 255) {
-            out[i] = MAKE_UINT32(in[2], in[1], in[0], a);
+            iv = MAKE_UINT32(in[2], in[1], in[0], a);
         } else {
-            out[i] = MAKE_UINT32(CLIP(in[2] * 255 / a),
-                                 CLIP(in[1] * 255 / a),
-                                 CLIP(in[0] * 255 / a), a);
+            iv = MAKE_UINT32(CLIP(in[2] * 255 / a),
+                             CLIP(in[1] * 255 / a),
+                             CLIP(in[0] * 255 / a), a);
         }
-        in += 4;
+        memcpy(_out, &iv, sizeof(iv));
+        in += 4; _out += 4;
     }
 }
 
@@ -849,11 +844,11 @@ static void
 unpackRGBAL(UINT8* _out, const UINT8* in, int pixels)
 {
     int i;
-    UINT32* out = (UINT32*) _out;
     /* RGBA, line interleaved */
-    for (i = 0; i < pixels; i++) {
-        out[i] = MAKE_UINT32(in[i], in[i+pixels], in[i+pixels+pixels],
-                             in[i+pixels+pixels+pixels]);
+    for (i = 0; i < pixels; i++, _out+=4) {
+        UINT32 iv = MAKE_UINT32(in[i], in[i+pixels], in[i+pixels+pixels],
+                                in[i+pixels+pixels+pixels]);
+        memcpy(_out, &iv, sizeof(iv));
     }
 }
 
@@ -861,10 +856,10 @@ void
 unpackRGBA16L(UINT8* _out, const UINT8* in, int pixels)
 {
     int i;
-    UINT32* out = (UINT32*) _out;
     /* 16-bit RGBA, little-endian order */
-    for (i = 0; i < pixels; i++) {
-        out[i] = MAKE_UINT32(in[1], in[3], in[5], in[7]);
+    for (i = 0; i < pixels; i++, _out+=4) {
+        UINT32 iv = MAKE_UINT32(in[1], in[3], in[5], in[7]);
+        memcpy(_out, &iv, sizeof(iv));
         in += 8;
     }
 }
@@ -873,10 +868,10 @@ void
 unpackRGBA16B(UINT8* _out, const UINT8* in, int pixels)
 {
     int i;
-    UINT32* out = (UINT32*) _out;
     /* 16-bit RGBA, big-endian order */
-    for (i = 0; i < pixels; i++) {
-        out[i] = MAKE_UINT32(in[0], in[2], in[4], in[6]);
+    for (i = 0; i < pixels; i++, _out+=4) {
+        UINT32 iv = MAKE_UINT32(in[0], in[2], in[4], in[6]);
+        memcpy(_out, &iv, sizeof(iv));
         in += 8;
     }
 }
@@ -885,11 +880,11 @@ static void
 unpackARGB(UINT8* _out, const UINT8* in, int pixels)
 {
     int i;
-    UINT32* out = (UINT32*) _out;
     /* RGBA, leading pad */
     for (i = 0; i < pixels; i++) {
-        out[i] = MAKE_UINT32(in[1], in[2], in[3], in[0]);
-        in += 4;
+        UINT32 iv = MAKE_UINT32(in[1], in[2], in[3], in[0]);
+        memcpy(_out, &iv, sizeof(iv));
+        in += 4; _out += 4;
     }
 }
 
@@ -897,11 +892,11 @@ static void
 unpackABGR(UINT8* _out, const UINT8* in, int pixels)
 {
     int i;
-    UINT32* out = (UINT32*) _out;
     /* RGBA, reversed bytes */
     for (i = 0; i < pixels; i++) {
-        out[i] = MAKE_UINT32(in[3], in[2], in[1], in[0]);
-        in += 4;
+        UINT32 iv = MAKE_UINT32(in[3], in[2], in[1], in[0]);
+        memcpy(_out, &iv, sizeof(iv));
+        in += 4; _out += 4;
     }
 }
 
@@ -909,11 +904,11 @@ static void
 unpackBGRA(UINT8* _out, const UINT8* in, int pixels)
 {
     int i;
-    UINT32* out = (UINT32*) _out;
     /* RGBA, reversed bytes */
     for (i = 0; i < pixels; i++) {
-        out[i] = MAKE_UINT32(in[2], in[1], in[0], in[3]);
-        in += 4;
+        UINT32 iv = MAKE_UINT32(in[2], in[1], in[0], in[3]);
+        memcpy(_out, &iv, sizeof(iv));
+        in += 4; _out += 4;
     }
 }
 
@@ -924,11 +919,11 @@ static void
 unpackCMYKI(UINT8* _out, const UINT8* in, int pixels)
 {
     int i;
-    UINT32* out = (UINT32*) _out;
     /* CMYK, inverted bytes (Photoshop 2.5) */
     for (i = 0; i < pixels; i++) {
-        out[i] = ~MAKE_UINT32(in[0], in[1], in[2], in[3]);
-        in += 4;
+        UINT32 iv = ~MAKE_UINT32(in[0], in[1], in[2], in[3]);
+        memcpy(_out, &iv, sizeof(iv));
+        in += 4; _out += 4;
     }
 }
 
@@ -1002,30 +997,30 @@ unpackI12_I16(UINT8* out, const UINT8* i
 #ifdef WORDS_BIGENDIAN
     UINT8* tmp = (UINT8 *)&pixel;
 #endif
-    UINT16* out16 = (UINT16 *)out;
     for (i = 0; i < pixels-1; i+=2) {
         pixel = (((UINT16) in[0]) << 4 ) + (in[1] >>4);
 #ifdef WORDS_BIGENDIAN
         out[0] = tmp[1];  out[1] = tmp[0];
 #else
-        out16[0] = pixel;
+        memcpy(out, &pixel, sizeof(pixel));
 #endif
 
+        out+=2;
         pixel = (((UINT16) (in[1] & 0x0F)) << 8) + in[2];
 #ifdef WORDS_BIGENDIAN
-        out[2] = tmp[1];  out[3] = tmp[0];
+        out[0] = tmp[1];  out[1] = tmp[0];
 #else
-        out16[1] = pixel;
+        memcpy(out, &pixel, sizeof(pixel));
 #endif
 
-		in += 3; out16 += 2; out+=4;
+        in += 3; out+=2;
     }
     if (i == pixels-1) {
         pixel = (((UINT16) in[0]) << 4 ) + (in[1] >>4);
 #ifdef WORDS_BIGENDIAN
         out[0] = tmp[1];  out[1] = tmp[0];
 #else
-        out16[0] = pixel;
+        memcpy(out, &pixel, sizeof(pixel));
 #endif
     }
 }
@@ -1056,44 +1051,20 @@ static void
 copy4skip1(UINT8* _out, const UINT8* in, int pixels)
 {
     int i;
-#ifdef __sparc
-    /* SPARC CPUs cannot read integers from nonaligned addresses. */
-    for (i = 0; i < pixels; i++) {
-        _out[0] = in[0];
-        _out[1] = in[1];
-        _out[2] = in[2];
-        _out[3] = in[3];
-        _out += 4; in += 5;
-    }
-#else
-    UINT32* out = (UINT32*) _out;
     for (i = 0; i < pixels; i++) {
-        out[i] = *(UINT32*)&in[0];
-        in += 5;
+        memcpy(_out, in, 4);
+        in += 5; _out += 4;
     }
-#endif
 }
 
 static void
 copy4skip2(UINT8* _out, const UINT8* in, int pixels)
 {
     int i;
-#ifdef __sparc
-    /* SPARC CPUs cannot read integers from nonaligned addresses. */
-    for (i = 0; i < pixels; i++) {
-        _out[0] = in[0];
-        _out[1] = in[1];
-        _out[2] = in[2];
-        _out[3] = in[3];
-        _out += 4; in += 6;
-    }
-#else
-    UINT32* out = (UINT32*) _out;
     for (i = 0; i < pixels; i++) {
-        out[i] = *(UINT32*)&in[0];
-        in += 6;
+        memcpy(_out, in, 4);
+        in += 6; _out += 4;
     }
-#endif
 }
 
 
