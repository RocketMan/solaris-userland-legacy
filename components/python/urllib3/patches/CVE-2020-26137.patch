Fixes CVE-2020-26137.

Description:
  urllib3 before 1.25.9 allows CRLF injection if the attacker controls the HTTP
  request method, as demonstrated by inserting CR and LF control characters in
  the first argument of putrequest(). NOTE: this is similar to CVE-2020-26116.

Upstream commit:
https://github.com/urllib3/urllib3/commit/1dd69c5c5982fae7c87a620d487c2ebf7a6b436b

--- urllib3-1.25.1/src/urllib3/connection.py
+++ urllib3-1.25.1/src/urllib3/connection.py
@@ -1,4 +1,5 @@
 from __future__ import absolute_import
+import re
 import datetime
 import logging
 import os
@@ -62,6 +63,8 @@ port_by_scheme = {
 # after 2016-01-01 (today - 2 years) AND before 2017-07-01 (today - 6 months)
 RECENT_DATE = datetime.date(2017, 6, 30)
 
+_CONTAINS_CONTROL_CHAR_RE = re.compile(r"[^-!#$%&'*+.^_`|~0-9a-zA-Z]")
+
 
 class DummyConnection(object):
     """Used to detect a failed ConnectionCls import."""
@@ -183,6 +186,17 @@ class HTTPConnection(_HTTPConnection, ob
         conn = self._new_conn()
         self._prepare_conn(conn)
 
+    def putrequest(self, method, url, *args, **kwargs):
+        """Send a request to the server"""
+        match = _CONTAINS_CONTROL_CHAR_RE.search(method)
+        if match:
+            raise ValueError(
+                "Method cannot contain non-token characters %r (found at least %r)"
+                % (method, match.group())
+            )
+
+        return _HTTPConnection.putrequest(self, method, url, *args, **kwargs)
+
     def request_chunked(self, method, url, body=None, headers=None):
         """
         Alternative to the common request method, which sends the
--- urllib3-1.25.1/test/with_dummyserver/test_connectionpool.py
+++ urllib3-1.25.1/test/with_dummyserver/test_connectionpool.py
@@ -673,6 +673,12 @@ class TestConnectionPool(HTTPDummyServer
         pool = HTTPConnectionPool('thishostdoesnotexist.invalid', self.port, timeout=0.001)
         self.assertRaises(MaxRetryError, pool.request, 'GET', '/test', retries=2)
 
+    @pytest.mark.parametrize("char", [" ", "\r", "\n", "\x00"])
+    def test_invalid_method_not_allowed(self, char):
+        with pytest.raises(ValueError):
+            with HTTPConnectionPool(self.host, self.port) as pool:
+                pool.request("GET" + char, "/")
+
     def test_source_address(self):
         for addr, is_ipv6 in VALID_SOURCE_ADDRESSES:
             if is_ipv6 and not HAS_IPV6_AND_DNS:
